let Store = require('electron-store');
let Path = require("path");
const fs = require('fs');


/**@class*/
class Config extends Store {
	/**@param {'test' | 'exam'} mode*/
	constructor(mode) {
		super();
		const {
			allowed_rhythm_deviation, allowed_tempo_deviation,
			current_subject, demo_type,
			errors_playingspeed, finished_trials_count,
			levels, truth_file_path
		} = super.get(`current_${mode}`);
		this.mode = mode;
		this.allowed_rhythm_deviation = allowed_rhythm_deviation;
		this.allowed_tempo_deviation = allowed_tempo_deviation;
		this.current_subject = current_subject;
		this.demo_type = demo_type;
		this.errors_playingspeed = errors_playingspeed;
		this.finished_trials_count = finished_trials_count;
		this.levels = levels;
		this.truth_file_path = truth_file_path;


	}

	/**@param {TConfigKey} key*/
	get(key) {
		return super.get(`current_${this.mode}.${key}`);
	}

	/**@param {Object | TConfigKey} keyOrObj
	 * @param value*/
	set(keyOrObj, value) {
		if (typeof key === 'object') {
			for (const k in key)
				super.set(k, key[k]);
			return;

		}
		super.set(key, value);
	}

}

class MyStore extends Store {

	constructor() {
		super();
		this._mode = 'test';
		this._doTruthFileCheck();

	}

	get mode() {
		return this._mode;
	}

	/**@param {'test' | 'exam'} value*/
	set mode(value) {
		if (value != 'test' && value != 'exam')
			throw new Error(`MyStore mode setter, got value: '${value}'. Must be either 'test' or 'exam'`);
		this._mode = value;
	}

	/**@private*/
	_doTruthFileCheck() {
		console.log('MyStore._doTruthFileCheck()');
		const truth = this.truth();
		truth.txt.allExist()
		     .then(async exist => {
			     if (exist) {
				     return Alert.small.success(`All "${truth.name}" txt files exist.`);
			     } else {
				     let txtFilesList = this.truthFilesList('txt').map(fsx.remove_ext);
				     let filteredTxts = txtFilesList.filter(a => txtFilesList.filter(txt => txt.startsWith(a)).length >= 3);
				     if (!bool(filteredTxts))
					     return await Alert.big.warning({
						     title: 'No valid truth files found',
						     html: 'There needs to be at least one txt file with 2 "on" and "off" counterparts.'
					     });


				     await Alert.big.blocking({
					     title: `Truth file invalid: ${truth.name}`,
					     html: '<b>Please choose one of the following valid truths:</b>',
				     }, {
					     strings: filteredTxts,
					     clickFn: async $s => {
						     try {
							     const currentConfig = this.currentConfig();
							     currentConfig.truth_file_path = 'lol';
							     await this.setTruthFilePath(new Truth(Path.join(this.truthsDirPath(), $s.text())));

							     this.setInCurrentConfig({
								     'finished_trials_count': 0,
								     'levels': []
							     });
							     // this.set(`current_${this.mode}.finished_trials_count`, 0);
							     // this.set(`current_${this.mode}.levels`, []);
							     /*this.set({
								     'current_test.finished_trials_count': 0,
								     'current_test.levels': []
							     });
							     */

							     reloadPage();
						     } catch (err) {
							     document.getElementById('swal2-title').innerText = err.message;
							     document.getElementById('swal2-content').style.display = 'none';
							     document.getElementsByClassName('swal2-icon swal2-warning')[0].style.display = 'inherit';
							     throw err;
						     }

					     }
				     });
			     }
		     });

	}

	// /**@return {TConfig}*/
	// currentTest() {
	// 	return this.get('current_test');
	// }
	/**@return {Config}*/
	currentConfig() {
		const _currentConfig = new Config(this.get(`current_${this.mode}`), this.get, this.set);
		// _currentConfig.on('set_levels', levels => this.set(`current_${this.mode}.levels`, levels));
		return _currentConfig;
	}

	setInCurrentConfig(kvpairs) {
		const basekey = `current_${this.mode}`;
		this.set();
		for (let [k, v] in kvpairs.items()) {

		}
	}


	/**@param {Truth} truth
	 @returns {Promise<Truth>}*/
	setTruthFilePath(truth) {
		return truth.txt.allExist()
		            .then(exist => {
			            if (exist) {
				            this.set(`current_${this.mode}.truth_file_path`, `experiments\\truths\\${truth.txt.base.name}`);
				            return truth;
			            } else {
				            throw new Error(`Not all txt files of truth exist: ${truth.txt.base.name}`);
			            }
		            });
	}

	/**@param {TDemoType} type*/
	setDemoType(type) {
		if (!type.in(['video', 'animation']))
			throw new Error(`setDemoMode(type = ${type}), can be either video or animation`);
		this.set(`current_${this.mode}.demo_type`, type);
	}

	/**@param {TLastPage} page*/
	setLastPage(page) {
		const validpages = ['exam', 'new_test', 'inside_test', 'record', 'file_tools', 'settings'];
		if (!page.in(validpages))
			throw new Error(`setLastPage(page = ${page}), must be one of ${validpages.join(', ')}`);

		this.set('last_page', page);
		if (page == 'exam')
			this.mode = 'exam';
		else
			this.mode = 'test';
	}

	/**@example
	 update('subjects', [names])
	 @param {string} K
	 @param kv
	 @return {*} */
	update(K, kv) {
		let V = this.get(K);
		if (Array.isArray(V)) {
			this.set(K, [...V, kv]);
		} else {
			Object.assign(V, kv);
			this.set(K, V);
		}
		return this.get(K);
	}

	/** @param {string} K
	 @return {TConfig} */
	increase(K) {
		let V = this.get(K);

		if (V === undefined)
			this.set(K, 1);
		else if (!isNaN(Math.floor(V)))
			this.set(K, int(V) + 1);
		else
			throw new TypeError("MyStore tried to increase a value that is not a number or string");

		return this.get('current_test');
	}

	rootAbsPath() {
		return this.get('root_abs_path');
	}

	vidSilenceLen() {
		return this.get('vid_silence_len');
	}

	/**"C:\Sync\Code\Python\Pyano\pyano_01\src\experiments\truths"
	 @return {string}*/
	truthsDirPath() {
		return Path.join(this.rootAbsPath(), 'experiments', 'truths');
	}

	/**@param {String?} extFilter
	 @return {string[]} truthFiles*/
	truthFilesList(extFilter = null) {
		if (extFilter != null)
			if (!extFilter.in(['txt', 'mid', 'mp4']))
				throw new Error(`truthFilesList(extFilter = ${extFilter}), must be either ['txt','mid','mp4'] or not at all`);

		const truthsDirPath = this.truthsDirPath();

		let truthFiles = [...new Set(fs.readdirSync(truthsDirPath))];
		if (extFilter != null)
			return truthFiles.filter(f => Path.extname(f) == `.${extFilter}`);
		return truthFiles;
	}

	/**"my_truth[.txt]"
	 @example
	 truthFileName()
	 >>> my_truth
	 truthFileName({withExtension:true})
	 >>> my_truth.txt
	 @param {boolean} withExtension
	 @return {string}*/
	truthFileName({ withExtension }) {

		const truthFilePath = this.get(`current_${this.mode}.truth_file_path`);
		if (withExtension)
			return fsx.basename(truthFilePath);
		else
			return fsx.basename(truthFilePath, '.txt');
	}


	/**"C:\Sync\Code\Python\Pyano\pyano_01\src\experiments\truths\my_truth[.?]"
	 @example
	 truthFilePath()
	 >>> "C:\Sync\Code\Python\Pyano\pyano_01\src\experiments\truths\my_truth"
	 truthFilePath('mid')
	 >>> "C:\Sync\Code\Python\Pyano\pyano_01\src\experiments\truths\my_truth.mid"
	 @param {String?} ext
	 @return {string}*/
	truthFilePath(ext = null) {
		let truthFileName = this.truthFileName({ withExtension: false });
		if (ext != null) {
			if (ext.includes('.'))
				throw new Error(`ext included dot. Pass only file type. received: ${ext}`);
			if (!ext.in(['txt', 'mid', 'mp4']))
				throw new Error(`ext is not txt, mid or mp4. Pass only one of these. received: ${ext}`);

			return Path.join(this.truthsDirPath(), `${truthFileName}.${ext}`);
		} else {
			return Path.join(this.truthsDirPath(), `${truthFileName}`);
		}
	}

	/**@return {Truth}*/
	truth() {
		return new Truth(Path.join(this.truthsDirPath(), Path.basename(this.get(`current_${this.mode}.truth_file_path`), '.txt')));
	}

	/** "C:\Sync\Code\Python\Pyano\pyano_01\src\experiments\subjects"
	 @return {string} */
	subjectsDirPath() {
		return Path.join(this.rootAbsPath(), 'experiments', 'subjects');
	}

	/** "gilad"
	 @return {string} */
	subjectName() {
		return this.get(`current_${this.mode}.current_subject`);
	}

	/** "C:\Sync\Code\Python\Pyano\pyano_01\src\experiments\subjects\gilad"
	 @return {string} */
	subjectDirPath() {
		return Path.join(this.subjectsDirPath(), this.subjectName());
	}

	salamanderDirPath() {
		return Path.join(this.rootAbsPath(), 'templates', 'Salamander/');
	}

	/**"c:\Sync\Code\Python\Pyano\pyano_01\src\experiments\subjects\gilad\fur_elise"
	 @return {string}*/
	testOutPath() {
		const currSubjectDir = this.subjectDirPath(); // ".../subjects/gilad"
		const truthFileName = this.truthFileName({ withExtension: false }); // "fur_elise"
		return Path.join(currSubjectDir, truthFileName);
	}


	/**Gets the current trial's path (join this.testOutPath() and level_${level_index}...), and returns a Truth of it
	 @return {Truth}*/
	trialTruth() {
		let [level_index, trial_index] = this.currentTrialCoords();
		return new Truth(Path.join(this.testOutPath(), `level_${level_index}_trial_${trial_index}`));
	}

	/**
	 * @return {{
	 * skip_whole_truth_demo: (function(): boolean),
	 * skip_level_intro_demo: (function(): boolean),
	 * skip_failed_trial_feedback: (function(): boolean),
	 * skip_passed_trial_feedback: (function(): boolean)
	 * toObj}
	 * }
	 */
	get dev() {
		const _dev = this.get('dev');
		return {
			skip_whole_truth_demo: () => _dev && this.get('devoptions.skip_whole_truth_demo'),
			skip_level_intro_demo: () => _dev && this.get('devoptions.skip_level_intro_demo'),
			skip_passed_trial_feedback: () => _dev && this.get('devoptions.skip_passed_trial_feedback'),
			skip_failed_trial_feedback: () => _dev && this.get('devoptions.skip_failed_trial_feedback'),
		};
	}

	// ***DYNAMIC CONTENT


	/**@return {boolean}*/
	isDemoVideo() {
		return this.currentConfig().demo_type == "video";
	}

	/**@return {boolean}*/
	isWholeTestOver() {
		let { levels, finished_trials_count } = this.currentConfig();
		return sum(levels.map(level => level.trials)) == finished_trials_count;
	}

	/**@return {number[]}*/
	currentTrialCoords() {
		let { levels, finished_trials_count } = this.currentConfig();
		let flatTrialsList = levels.map(level => level.trials);
		for (let [levelIndex, trialsNum] of enumerate(flatTrialsList)) {

			let trialSumSoFar = sum(flatTrialsList.slice(0, levelIndex + 1));
			if (trialSumSoFar > finished_trials_count)
				return [levelIndex, trialsNum - (trialSumSoFar - finished_trials_count)];
		}
		throw "currentTrialCoords: out of index error";
	}


	/**@return {Level}*/
	getCurrentLevel() {
		let [level_index, trial_index] = this.currentTrialCoords();
		return new Level(this.currentConfig().levels[level_index], level_index, trial_index);
	}

	/**@return {Levels}*/
	getLevels() {
		let [level_index, trial_index] = this.currentTrialCoords();
		return new Levels(this.currentConfig().levels, level_index, trial_index);
	}


}

/**
 * @type {MyStore}
 */
module.exports = MyStore;

// let { enumerate, sum } = require("pyano_local_modules/util");

let Store = require('electron-store');
let Path = require("path");
const util = () => require("pyano_local_modules/util");
const fs = require('fs');

class MyStore extends Store {
	constructor() {
		super();
		this._doTruthFileCheck();

	}

	/**@private*/
	_doTruthFileCheck() {
		const truthFilePath = Path.join(this.truthsDirPath(), this.truthFileName({ withExtension: true }));

		fs.access(truthFilePath, fs.constants.F_OK, err => {
			if (err) {
				let { remote } = require("electron");
				Alert.big.blocking({
					title: `Truth file not found: ${Path.basename(truthFilePath)}`,
					html: '<b>Please choose one of the following:</b>',
				}, {
					strings: this.truthFilesList('txt'),
					clickFn: $s => {
						this.setTruthFilePath(Path.basename($s.text(), '.txt'));
						this.set({
							'current_test.finished_trials_count': 0,
							'current_test.levels': []
						});
						remote.getCurrentWindow().reload();
					}
				});


			}
		});
	}

	/**@return {TCurrentTest}*/
	currentTest() {
		return this.get('current_test');
	}

	/**@param {string} pathNoExt - Can be an absolute, partial ("relative") or a basename
	 @returns {Promise<String>} Full truth file path with extension*/
	setTruthFilePath(pathNoExt) {
		if (util().bool(Path.extname(pathNoExt)))
			throw new Error(`pathNoExt included dot. Pass without extension. received: ${pathNoExt}`);
		const fileWithExt = `${pathNoExt}.txt`; // might be a relative (../../something.txt)
		const truthFileName = Path.basename(fileWithExt);
		const truthFilePath = Path.join(this.truthsDirPath(), truthFileName);
		return util().path_exists(truthFilePath)
		             .then(exists => {
			             if (exists) {
				             this.set('current_test.truth_file_path', `experiments\\truths\\${truthFileName}`);
				             return truthFilePath;
			             } else {
				             throw new Error(`Received truth file that doesn't exist: ${truthFilePath}`);
			             }
		             });
	}

	setDemoType(type) {
		if (!type.in(['video', 'animation']))
			throw new Error(`setDemoMode(type = ${type}), can be either video or animation`);
		this.set('current_test.demo_type', type);
	}

	setLastPage(page) {
		if (!page.in(['new_test', 'inside_test', 'record', 'file_tools', 'settings']))
			throw new Error(`setLastPage(page = ${page}), can be either ['new_test','inside_test','record','file_tools','settings']`);
		this.set('last_page', page);
	}

	/**@example
	 update('subjects', [names])
	 @param {string} K
	 @param kv
	 @return {*} */
	update(K, kv) {
		let V = this.get(K);
		if (Array.isArray(V)) {
			this.set(K, [...V, kv]);
		} else {
			Object.assign(V, kv);
			this.set(K, V);
		}
		return this.get(K);
	}

	/** @param {string} K
	 @return {TCurrentTest} */
	increase(K) {
		let V = this.get(K);
		this.set(K, V + 1);
		return this.get('current_test');
	}

	rootAbsPath() {
		return this.get('root_abs_path');
	}

	vidSilenceLen() {
		return this.get('vid_silence_len');
	}

	/**"C:\Sync\Code\Python\Pyano\pyano_01\src\experiments\truths"
	 @return {string}*/
	truthsDirPath() {
		return Path.join(this.rootAbsPath(), 'experiments', 'truths');
	}

	/**@param {String?} extFilter
	 @return {String[]} truthFiles*/
	truthFilesList(extFilter = null) {
		if (extFilter != null)
			if (!extFilter.in(['txt', 'mid', 'mp4']))
				throw new Error(`truthFilesList(extFilter = ${extFilter}), must be either ['txt','mid','mp4'] or not at all`);

		const truthsDirPath = this.truthsDirPath();

		let truthFiles = [...new Set(fs.readdirSync(truthsDirPath))];
		if (extFilter != null)
			return truthFiles.filter(f => Path.extname(f) == `.${extFilter}`);
		return truthFiles;
	}

	/**"my_truth[.txt]"
	 @example
	 truthFileName()
	 >>> my_truth
	 truthFileName({withExtension:true})
	 >>> my_truth.txt
	 @param {boolean} withExtension
	 @return {string}*/
	truthFileName({ withExtension }) {
		const truthFilePath = this.get("current_test.truth_file_path");
		if (withExtension)
			return Path.basename(truthFilePath);
		else
			return Path.basename(truthFilePath, '.txt');
	}


	/**"C:\Sync\Code\Python\Pyano\pyano_01\src\experiments\truths\my_truth[.?]"
	 @example
	 truthFilePath()
	 >>> "C:\Sync\Code\Python\Pyano\pyano_01\src\experiments\truths\my_truth"
	 truthFilePath('mid')
	 >>> "C:\Sync\Code\Python\Pyano\pyano_01\src\experiments\truths\my_truth.mid"
	 @param {String?} ext
	 @return {string}*/
	truthFilePath(ext = null) {
		let truthFileName = this.truthFileName({ withExtension: false });
		if (ext != null) {
			if (ext.includes('.'))
				throw new Error(`ext included dot. Pass only file type. received: ${ext}`);
			if (!ext.in(['txt', 'mid', 'mp4']))
				throw new Error(`ext is not txt, mid or mp4. Pass only one of these. received: ${ext}`);

			return Path.join(this.truthsDirPath(), `${truthFileName}.${ext}`);
		} else
			return Path.join(this.truthsDirPath(), `${truthFileName}`);
	}

	/**@return {Truth}*/
	truth() {
		return new Truth(Path.join(this.truthsDirPath(), this.truthFileName({ withExtension: false })));
	}

	/** "C:\Sync\Code\Python\Pyano\pyano_01\src\experiments\subjects"
	 @return {string} */
	subjectsDirPath() {
		return Path.join(this.rootAbsPath(), 'experiments', 'subjects');
	}

	/** "gilad"
	 @return {string} */
	subjectName() {
		return this.get('current_test.current_subject');
	}

	/** "C:\Sync\Code\Python\Pyano\pyano_01\src\experiments\subjects\gilad"
	 @return {string} */
	subjectDirPath() {
		return Path.join(this.subjectsDirPath(), this.subjectName());
	}

	salamanderDirPath() {
		return Path.join(this.rootAbsPath(), 'templates', 'Salamander/');
	}

	/**"c:\Sync\Code\Python\Pyano\pyano_01\src\experiments\subjects\gilad\fur_elise_accuracy"
	 @return {string}
	 */
	testOutPath() {
		const currSubjectDir = this.subjectDirPath(); // ".../subjects/gilad"
		const truthFileName = this.truthFileName({ withExtension: false }); // "fur_elise"
		const { learning_type } = this.get('current_test'); // "accuracy"
		return Path.join(currSubjectDir, `${truthFileName}_${learning_type}`);
	}

	/**"c:\Sync\Code\Python\Pyano\pyano_01\src\experiments\subjects\gilad\fur_elise_accuracy\level_0_trial_0[.?]"
	 @example
	 trialFilePath()
	 >>> "c:\Sync\Code\Python\Pyano\pyano_01\src\experiments\subjects\gilad\fur_elise\level_0_trial_0"
	 trialFilePath('mid')
	 >>> "c:\Sync\Code\Python\Pyano\pyano_01\src\experiments\subjects\gilad\fur_elise\level_0_trial_0.mid"
	 @param {?string} [ext=null]
	 @return {string}*/
	trialFilePath(ext = null) {
		let [level_index, trial_index] = this.currentTrialCoords();
		const noExtension = Path.join(this.testOutPath(), `level_${level_index}_trial_${trial_index}`);
		if (ext == null)
			return noExtension;

		if (ext.includes('.'))
			throw new Error(`ext included dot. Pass only file type. received: ${ext}`);
		if (!ext.in(['txt', 'mid']))
			throw new Error(`ext is not txt or mid. Pass only one of these. received: ${ext}`);
		return `${noExtension}.${ext}`;

	}


	// ***DYNAMIC CONTENT

	/**@return {boolean}*/
	isLearningTempo() {
		return this.currentTest().learning_type == "tempo";
	}

	/**@return {boolean}*/
	isDemoVideo() {
		return this.currentTest().demo_type == "video";
	}

	/**@return {boolean}*/
	isWholeTestOver() {
		let { levels, finished_trials_count } = this.currentTest();
		let { sum } = util();
		return sum(levels.map(level => level.trials)) == finished_trials_count;
	}

	/**@return {number[]}*/
	currentTrialCoords() {
		let { levels, finished_trials_count } = this.currentTest();
		let flatTrialsList = levels.map(level => level.trials);
		for (let [levelIndex, trialsNum] of enumerate(flatTrialsList)) {

			let sumSoFar = sum(flatTrialsList.slice(0, levelIndex + 1));
			if (sumSoFar > finished_trials_count)
				return [levelIndex, trialsNum - (sumSoFar - finished_trials_count)];
		}
		throw "currentTrialCoords: out of index error";
	}

	/**@return {number}*/
	numOfNotesCurrLevel() {
		let level_index = this.currentTrialCoords()[0];
		return this.currentTest().levels[level_index].notes;
	}

	/**@return {number}*/
	truthFileTotalNotes() {

		const truth = this.truth();
		try {
			return fs.readFileSync(truth.txt.on.path, { encoding: 'utf8' })
			         .split('\n')
			         .filter(line => bool(line)).length;
		} catch (e) {}
	}
}

/**
 * @type {MyStore}
 */
module.exports = MyStore;

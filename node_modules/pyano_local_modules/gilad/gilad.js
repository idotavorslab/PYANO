let Tone = require("tone");
const Transport = Tone.Transport;
const $ = require("jquery");
let {
	EStore
} = require("pyano_local_modules/ext_libs");
let Piano = require("./Piano");
let events = require("events");
const WebMidi = require("webmidi");

const MidiConvert = require("midiconvert");


let TonejsMidi = require("@tonejs/midi");

const fs = require('fs');
Tone.context.lookAhead = 0;
Tone.context.latencyHint = 'fastest';


/**@param {Truth} truth
 * @return {Promise<Truth>}*/
async function toTxtFromMidi(truth) {


	let midiRead = await MidiConvert.load(truth.midi.path);

	let readTrack = midiRead.tracks.find(t => t.instrumentNumber == 0 &&
	                                          !t.notes.isEmpty());


	let txtWriteStreamOn = await fs.createWriteStream(truth.txt.on.path, {
		flags: 'w',
		encoding: 'utf8',
	});
	let ts = new Date() / 1000;
	const noteOns = readTrack.notes;
	for (let noteOn of noteOns) {
		const on = `${round(ts + noteOn.time, 5)}\tnote=${noteOn.midi}\tvelocity=${round(noteOn.velocity * 127)}\ton\n`;
		txtWriteStreamOn.write(on);
	}

	txtWriteStreamOn.end();

	let txtWriteStreamOff = await fs.createWriteStream(truth.txt.off.path, {
		flags: 'w',
		encoding: 'utf8',
	});
	let noteOffs = readTrack.noteOffs;
	noteOffs = noteOffs.sort((a, b) => a.time - b.time);
	for (let noteOff of noteOffs) {
		const off = `${round(ts + noteOff.time, 5)}\tnote=${noteOff.midi}\tvelocity=999\toff\n`;
		txtWriteStreamOff.write(off);
	}
	txtWriteStreamOff.end();

	return truth;

}

/**
 @param {TOnOffPairs} on_off_pairs
 @param {Truth} truth
 */
async function toMidiFromMessages(on_off_pairs, truth) {


	if (await truth.midi.exists())
		return Promise.reject(`midi file exists: ${truth.midi}`);
	if (!(await truth.txt.allExist()))
		return Promise.reject(`not all txt file exist: ${truth.txt.base}`);
	let midiWrite = new TonejsMidi();
	midiWrite.addTrack();


	const firstMsgTime = on_off_pairs[0][0].time - 0.01;


	for (let [on_msg, off_msg] of on_off_pairs) {


		const onProps = {
			midi: on_msg.note,
			time: on_msg.time - firstMsgTime,
			velocity: on_msg.velocity / 127,
			noteOffVelocity: 1,
			duration: off_msg.time - on_msg.time,
		};

		midiWrite.tracks[0].addNote(onProps);
	}


	fs.writeFile(truth.midi.path, new Buffer(midiWrite.toArray()), err => {
		if (err) {
			Alert.big.blocking({
				title: `Something went wrong writing this trial's midi file. Please restart experiment`,
				html: `Error: ${err.message}`
			});
			throw err;
		}
	});
}

/**@param {playMidiFileOptions} options
 @return {Promise<Piano>}*/
async function playMidiFile(options) {
	let {
		truth,
		animation,
		numOfNotes,
		playbackRate,
		mistakes,
		animationPiano
	} = options;
	console.log(`ðŸŽ¹ playMidiFile(), using animationPiano: [${animationPiano.name}]`, options);

	/*if (!animationPiano)
		return Promise.reject(`playMidiFile() didn't receive param animationPiano`);
	if (!truth)
		return Promise.reject(`playMidiFile() didn't receive param truth`);
	if (!animationPiano._loaded) {
		console.log(`\tplayMidiFile() passed animationPiano was NOT loaded (shouldn't happen)`);
		await animationPiano.load();
		Alert.small.success('Piano loaded');

		console.log(`\tplayMidiFile() done loading passed (unloaded) animationPiano (shouldn't happen)`);
	}
	if (!(await truth.midi.exists()))
		return Promise.reject(`playMidiFile() midi path doesn't exist: "${truth.midi.path}"`);
	*/
	let midiRead = await MidiConvert.load(truth.midi.path);

	try {
		return new Promise(async resolve => {


			Transport.bpm.value = midiRead.bpm;

			Transport.timeSignature = midiRead.timeSignature;
			console.log('before awaiting Transport.start()');
			await Transport.start();
			console.log('done awaiting Transport.start()');

			let readTrack = midiRead.tracks.find(t => t.instrumentNumber == 0 && !t.notes.isEmpty());


			const scheduleNoteOn = (onTime, onEvent) => {
				let {
					midi: note,
					time,
					velocity,
					duration
				} = onEvent;
				animationPiano.keyDown(note, time, velocity);

				if (!animation)
					return;

				let fill = 'green';
				if (mistakes) {
					const index = noteOns.indexOf(onEvent);
					if (bool(mistakes[index])) {
						fill = mistakes[index] == 'accuracy' ? 'red' : '#2252C1';
					}
				}
				let noteDuration = duration * 1000;
				animation.markKey(note, noteDuration, fill);

			};

			const scheduleNoteOff = (offTime, offEvent) => {

				let index = noteOffs.indexOf(offEvent);
				const {
					time,
					velocity,
					midi: note
				} = offEvent;
				animationPiano.keyUp(note, time, velocity);
				if (skipFade) {
					console.log('piano skipFade, returning');
					Transport.stop();
					offPart.dispose();
					onPart.dispose();
					animationPiano.stopAll();
					return resolve(animationPiano);
				}
				if (index == noteOffs.length - 1) {
					Transport.stop();
					offPart.dispose();
					onPart.dispose();
					animationPiano.stopAll();
					return resolve(animationPiano);

				}
			};

			// let sustain = new Tone.Part(schedulePedal, track.controlChanges[64]).start(0);

			let [noteOns, noteOffs] = _sliceNotes(readTrack, numOfNotes, playbackRate);

			let offPart = new Tone.Part(scheduleNoteOff, noteOffs).start(0);
			let onPart = new Tone.Part(scheduleNoteOn, noteOns).start(0);


		});
	} catch (e) {
		Alert.big.blocking({
			title: `Something went wrong playing the midi file. Please refresh experiment`,
			html: `Previous trials saved. error: ${e.message}`
		});
	}

}

function _sliceNotes(readTrack, numOfNotes, playbackRate) {

	let noteOffs = readTrack.noteOffs;
	let noteOns = readTrack.notes;
	if (!numOfNotes && !playbackRate)
		return [noteOns, noteOffs];


	if (numOfNotes)
		noteOffs = noteOffs.slice(0, numOfNotes);
	if (numOfNotes)
		noteOns = noteOns.slice(0, numOfNotes);

	console.log(...small('\tðŸŽ¹ _sliceNotes()'), {
		noteOns,
		noteOffs
	});
	if (playbackRate) {
		for (let [i, note] of enumerate(noteOns)) {
			noteOns[i].duration = note.duration / playbackRate;
			noteOns[i].time = note.time / playbackRate;
		}
		for (let [i, note] of enumerate(noteOffs)) {
			noteOffs[i].duration = note.duration / playbackRate;
			noteOffs[i].time = note.time / playbackRate;
		}

	}
	return [noteOns, noteOffs];
}


class Midi extends events.EventEmitter {
	/**@param {string} name*/
	constructor({ name }) {
		super();
		this.name = name;
		this._shouldWrite = false;
		/**@type {WriteStream}*/
		this._onTxtWriteStream = undefined;
		/**@type {WriteStream}*/
		this._offTxtWriteStream = undefined;

		this._isInputConnected = false;
		this._isOutputConnected = false;

		// /**@type {Piano}*/
		// this._userPiano = new Piano(name).toMaster();
		/*this._userPiano.load()
		    .then(() => {
			    // TODO: mute is ALWAYS true. record page, insidetest.
			    let volume = muteUserPiano ? -Infinity : 0;
			    console.log(`ðŸŽ¹ [${this.name}]`, {
				    volume,
				    name,
				    muteUserPiano
			    });
			    this._userPiano.setVolume('note', volume);
			    this._enableWebMidi();
		    });
		*/
		this._enableWebMidi();

		/*this.on('keyDown', (note, velocity) => {
			console.warn(`ðŸŽ¹ [${this.name}] this on keyDown`);
			this._writeNoteOnToTxt(note, velocity);
		});

		this.on('keyUp', (note, velocity) => {
			console.warn(`ðŸŽ¹ [${this.name}] this on keyUp`);
			this._writeNoteOffToTxt(note, velocity);
		});

		this.on('pedalDown', () => {
			this._userPiano.pedalDown();
		});

		this.on('pedalUp', () => {
			this._userPiano.pedalUp();
		});
		*/

	}

	isInOutConnected() {
		return this._isInputConnected && this._isOutputConnected;
	}

	/**@param {TOnOffPairs} on_off_pairs
	 @param {Truth} truth*/
	async endOnOffTxtStreamsAndWriteMidi(on_off_pairs, truth) {
		console.log(`ðŸŽ¹ [${this.name}] %cendOnOffTxtStreamsAndWriteMidi(${truth.name})`, 'font-weight:900');
		// check private members and throw
		if (!this._shouldWrite) {
			Alert.small.warning('Closing txt file streams, _shouldWrite wasnt true (should have been)');
			console.error("endOnOffTxtStreamsAndWriteMidi() this._shouldWrite was NOT true (should have been)");
		}

		if (this._onTxtWriteStream === undefined) {
			Alert.small.warning('Closing txt file streams, on txt stream was undefined (shouldnt have been)');
			console.error("endOnOffTxtStreamsAndWriteMidi() this._onTxtWriteStream WAS undefined (should not have been)");
		}

		if (this._offTxtWriteStream === undefined) {
			Alert.small.warning('Closing txt file streams, off txt stream was undefined (shouldnt have been)');
			console.error("endOnOffTxtStreamsAndWriteMidi() this._offTxtWriteStream WAS undefined (should not have been)");
		}

		if (!WebMidi.enabled) {
			Alert.small.warning('Closing txt file streams, WebMidi wasnt enabled (shouldnt have been)');
			console.error(`endOnOffTxtStreamsAndWriteMidi(), WebMidi.enabled == false`);
		}


		this._shouldWrite = false;
		try {
			this._onTxtWriteStream.end();
		} catch (e) {

		}
		this._onTxtWriteStream = undefined;
		try {
			this._offTxtWriteStream.end();
		} catch (e) {

		}
		this._offTxtWriteStream = undefined;
		await toMidiFromMessages(on_off_pairs, truth);

	}

	/**
	 @param {Truth} truth
	 @return {Promise<Truth>}
	 */
	async newOnOffTxtWriteStreams(truth) {
		console.log(`ðŸŽ¹ [${this.name}] %cnewOnOffTxtWriteStreams(${truth.name})`, 'font-weight:900');

		if (this._shouldWrite) {
			Alert.big.blocking({
				title: 'Something went wrong (this._shouldWrite was true)',
				html: 'Previous trials saved. Please restart experiment'
			});
			return console.error("newOnOffTxtWriteStreams() was called but this._shouldWrite was already true");
		}
		if (this._onTxtWriteStream !== undefined) {
			Alert.big.blocking({
				title: 'Something went wrong (onTxtWriteStream was NOT undefined)',
				html: 'Previous trials saved. Please restart experiment'
			});
			return console.error("newOnOffTxtWriteStreams() was called but this._onTxtWriteStream was NOT undefined (should have been)");
		}
		if (this._offTxtWriteStream !== undefined) {
			Alert.big.blocking({
				title: 'Something went wrong (offTxtWriteStream was NOT undefined)',
				html: 'Previous trials saved. Please restart experiment'
			});
			return console.error("newOnOffTxtWriteStreams() was called but this._offTxtWriteStream was NOT undefined (should have been)");
		}

		/*if (!WebMidi.enabled) {
			Alert.big.blocking({
				title: 'Something went wrong (WebMidi wasnt enabled)',
				html: 'Previous trials saved. Please restart experiment'
			});
			return console.error(`newOnOffTxtWriteStreams(), WebMidi.enabled == false`);
		}
		*/


		this._shouldWrite = true;
		/*console.log(...small(`\tðŸŽ¹ [${this.name}] this._userPiano is ${this._userPiano._loaded
		                                                               ? 'loaded (good)'
		                                                               : 'NOT loaded (not good, launching blockingMixin)'}`));
		if (!this._userPiano._loaded) {
			console.log("\nbig blocking piano loading mixin");
			await Alert.big.blocking({
				title: 'Loading piano',
				text: 'Please wait a few seconds...',
				onOpen: async modal => {
					this._userPiano.progress(prog => console.log(`\tðŸŽ¹ prog: ${prog}`));
					await this._userPiano.load();
					const $modal = $(modal);
					$modal.find('#swal2-title').text('Load complete');
					$modal.find('#swal2-content').text('Start playing!');
					await asx.$fadeOut($modal.find('.swal2-loading'), 300);
					await asx.wait(300);
					modal.classList.add('fadeOutUp', 'faster');
					await asx.wait(500);
					Alert.close();
				},


			});

			console.log(`\tðŸŽ¹ done loading _userPiano`);
		}
		*/

		const options = {
			flags: 'w',
			encoding: 'utf8',
		};
		this._onTxtWriteStream = fs.createWriteStream(truth.txt.on.path, options);
		this._offTxtWriteStream = fs.createWriteStream(truth.txt.off.path, options);

		return truth;

	}

	_writeNoteOnToTxt(note, velocity) {


		if (!this._shouldWrite) {
			Alert.big.blocking({ title: `Something went wrong (!this._shouldWrite)`, text: `Please restart experiment` });
			return console.error(`ðŸŽ¹ _writeNoteOnToTxt returning prematurely because !this._shouldWrite`);
		}
		if (this._onTxtWriteStream === undefined) {
			Alert.big.blocking({
				title: 'Something went wrong (onTxtWriteStream was undefined)',
				html: 'Previous trials saved. Please restart experiment'
			});
			return console.error("_writeNoteOnToTxt() was called but this._onTxtWriteStream was undefined (should not have been)");
		}
		const ts = new Date() / 1000;
		this._onTxtWriteStream.write(`${round(ts, 5)}\tnote=${note}\tvelocity=${round(velocity * 127)}\ton\n`);

		// let time = Tone.now();
		// this._userPiano.keyDown(note, time, velocity);
	}

	_writeNoteOffToTxt(note) {
		if (!this._shouldWrite) {
			Alert.big.blocking({ title: `Something went wrong (!this._shouldWrite)`, text: `Please restart experiment` });
			return console.error(`ðŸŽ¹ _writeNoteOffToTxt returning prematurely because !this._shouldWrite`);
		}
		if (this._offTxtWriteStream === undefined) {
			Alert.big.blocking({
				title: 'Something went wrong (offTxtWriteStream was undefined)',
				html: 'Previous trials saved. Please restart experiment'
			});
			return console.error("_writeNoteOffToTxt() was called but this._offTxtWriteStream was undefined (should not have been)");
		}
		let ts = new Date() / 1000;
		this._offTxtWriteStream.write(`${round(ts, 5)}\tnote=${note}\tvelocity=999\toff\n`);

		// let time = Tone.now();
		// this._userPiano.keyUp(note, time, velocity);
	}


	_enableWebMidi() {
		const _bindInput = inputDevice => {
			console.log(...small('ðŸŽ¹ _enableWebMidi()._bindInput(inputDevice): '), inputDevice);
			if (!WebMidi.enabled)
				return console.error('ðŸŽ¹ _enableWebMidi()._bindInput(inputDevice), WebMidi.enabled == false, inputDevice:', inputDevice);
			WebMidi.addListener('disconnected', device => {
				Alert.big.warning({
					title: 'Keyboard disconnected! Please turn it on again',
					text: 'Go back to "New Experiment" after turning it on'
				});
				console.error("ðŸŽ¹ DEVICE DISCONNECTED", device);
				/*if (device.input) {
					device.input.removeListener('noteOn');
					device.input.removeListener('noteOff');
					WebMidi.disable();
				}
				*/
			});
			inputDevice.addListener('noteon', 'all', event => {
				this._writeNoteOnToTxt(event.note.number, event.velocity);
			});
			inputDevice.addListener('noteoff', 'all', event => {
				this._writeNoteOffToTxt(event.note.number);
			});

			/*inputDevice.addListener('controlchange', "all", event => {
				if (event.controller.name === 'holdpedal') {
					this.emit(event.value ?
					          'pedalDown' :
					          'pedalUp');
				}
			});
			*/

		};
		if (WebMidi.enabled)
			return console.error('ðŸŽ¹ _enableWebMidi() called from constructor, but was already Webmidi.enabled!');

		WebMidi.enable(err => {
			if (err)
				return console.error('ðŸŽ¹ Webmidi.enable() err!', err);

			if (WebMidi.inputs) {
				for (const inputDevice of WebMidi.inputs) {
					_bindInput(inputDevice);
				}
			} else {
				console.error('_enableWebMidi() - on WebMidi.enable, no error but no WebMidi.inputs!');
			}


			WebMidi.addListener('connected', device => {
				const deviceType = device.port.type;
				console.log(...small(`ðŸŽ¹ WebMidi connected ${deviceType}`));
				if (deviceType == 'input')
					this._isInputConnected = true;
				else if (deviceType == 'output')
					this._isOutputConnected = true;
				if (device.input)
					_bindInput(device.input);


			});


		});
	}


}


module.exports = {
	Midi,
	toMidiFromMessages,
	toTxtFromMidi,
	playMidiFile
};

// **gilad/index.js
const Tone = require("tone");
const Transport = Tone.Transport;
const $ = require("jquery");
let { EStore } = require("pyano_local_modules/ext_libs");
let Piano = require("./Piano");
let events = require("events");
let Swal = require("sweetalert2");
const WebMidi = require("webmidi");

let { wait, replace_ext, bool, enumerate, round, max, path_exists, $fadeOut } = require("pyano_local_modules/util");
const MidiConvert = require("midiconvert");


let TonejsMidi = require("@tonejs/midi");
let { Alert, blockingSwalMixin } = require("pyano_local_modules/util/Alert");

const fs = require('fs');
const Path = require('path');
Tone.context.lookAhead = 0;
Tone.context.latencyHint = 'fastest';

function _isBadPath(path, ext) {
	const fullExt = `.${ext}`;
	let bad = false;
	if (!path.endsWith(fullExt)) {
		console.error(`Path doesnt end with .txt. path: ${path}`);
		bad = true;
	}
	if (path.lastIndexOf(fullExt) != path.indexOf(fullExt)) {
		console.error(`Path has multiple .txt: ${path}`);
		bad = true;
	}
	return bad;
}

/**@param {String} midiFilePath*/
async function toTxtFromMidi(midiFilePath) {

	if (_isBadPath(midiFilePath, 'mid'))
		throw new Error(`Bad midi file path: ${midiFilePath}`);

	let midiRead = await MidiConvert.load(midiFilePath);
	let readTrack = midiRead.tracks.find(t => t.instrumentNumber == 0 &&
	                                          !t.notes.isEmpty());


	const txtFilePath = replace_ext(midiFilePath, 'txt');
	let exists = await path_exists(txtFilePath);
	if (exists) {
		throw new Error(`toTxtFromMidi() txtFilePath exists. ${txtFilePath}`);

	}

	let txtWriteStream = await fs.createWriteStream(txtFilePath, {
		flags: 'w',
		encoding: 'utf8',
	});
	let ts = new Date() / 1000;
	for (let note of readTrack.notes) {
		let {
			midi,
			time,
			velocity,
			duration
		} = note;
		txtWriteStream.write(`${ts + time}\tnote=${midi}\tvelocity=${round(velocity * 127)}\tduration=${duration}\n`);
	}

	txtWriteStream.end();


}

/**
 @param {TMessage[]} messages
 @param {String} midiFilePath
 */
async function toMidiFromMessages(messages, midiFilePath) {
	if (_isBadPath(midiFilePath, 'mid'))
		throw new Error(`Bad midi file path: ${midiFilePath}`);

	let exists = await path_exists(midiFilePath);
	if (exists) {
		throw new Error(`toMidiFromMessages() midiFilePath exists. ${midiFilePath}`);
	}
	let midiWrite = new TonejsMidi();
	midiWrite.addTrack();

	const firstMsgTime = messages[0].time - 0.01;
	for (let [i, msg] of enumerate(messages)) {
		if (i == 0)
			continue;

		let previousMsg = messages[i - 1];
		midiWrite.tracks[0].addNote({
			midi: previousMsg.note,
			time: previousMsg.time - firstMsgTime,
			velocity: previousMsg.velocity / 127,
			noteOffVelocity: previousMsg.velocity / 127,
			duration: max(msg.time_delta, 0.3),
		});
	}
	let lastMsg = messages.last();
	midiWrite.tracks[0].addNote({
		midi: lastMsg.note,
		time: lastMsg.time - firstMsgTime,
		velocity: lastMsg.velocity / 127,
		noteOffVelocity: lastMsg.velocity / 127,
		duration: 1,
	});

	await fs.writeFile(midiFilePath, new Buffer(midiWrite.toArray()), err => {
		if (err) throw err;
	});
}

class Midi extends events.EventEmitter {
	/**@param {String} name
	 @param {Boolean?} muteUserPiano*/
	constructor({ name, muteUserPiano = true }) {
		super();
		this.name = name;
		this._shouldWrite = false;
		/**@type {WriteStream}*/
		this._txtWriteStream = undefined;


		/**@type {Piano|Tone.AudioNode}*/
		this._userPiano = new Piano(`file:///${EStore.salamanderDirPath()}`, name, [21, 108], 5).toMaster();
		Alert.small.info('Loading piano in the background', 'You can still use the page while it does');
		this._userPiano.load();
		let volume = muteUserPiano
		             ? -Infinity
		             : 0;
		console.log(`ðŸŽ¹ [${this.name}]`, { volume, name, muteUserPiano });
		this._userPiano.setVolume('note', volume);
		this._enableWebMidi();

		this.on('keyDown', (note, velocity) => {
			console.warn(`[${this.name}] this on keyDown`);
			this._playNoteAndMaybeWriteTxt(note, velocity);
		});

		this.on('keyUp', (note, velocity) => {
			console.warn(`[${this.name}] this on keyUp`);
			this._releaseNote(note, velocity);
		});


		this.on('pedalDown', () => {
			this._userPiano.pedalDown();
		});

		this.on('pedalUp', () => {
			this._userPiano.pedalUp();
		});

	}


	/**
	 @param {TMessage[]} messages
	 @param {String} midiFilePath*/
	async endTxtAndWriteMidi(messages, midiFilePath) {
		console.log(`ðŸŽ¹ [${this.name}] endTxtAndWriteMidi(bn: ${Path.basename(midiFilePath)})`);
		// check private members and throw
		(() => {
			if (!this._shouldWrite) {
				console.error("endTxtAndWriteMidi() this._shouldWrite was NOT true");
			}
			if (this._txtWriteStream == undefined) {
				console.error("endTxtAndWriteMidi() this._txtWriteStream WAS undefined (should not have been)");
			}

			if (!midiFilePath.endsWith('.mid')) {
				console.error(`endTxtAndWriteMidi(), midiFilePath doesnt end with .mid. midiFilePath: ${midiFilePath}`);
			}
			if (midiFilePath.lastIndexOf('.mid') != midiFilePath.indexOf('.mid')) {
				console.error(`endTxtAndWriteMidi(), midiFilePath has multiple .mid: ${midiFilePath}`);
			}
			if (!WebMidi.enabled)
				console.error(`endTxtAndWriteMidi(), WebMidi.enabled == false`);

		})();

		this._shouldWrite = false;
		this._txtWriteStream.end();
		this._txtWriteStream = undefined;

		await toMidiFromMessages(messages, midiFilePath);

	}

	/**
	 @param {String} txtFilePath
	 @return {Promise<String>}
	 */
	async newTxtStreamAndMaybeLoadUserPiano(txtFilePath) {
		console.log(`ðŸŽ¹ [${this.name}] newTxtStreamAndMaybeLoadUserPiano(bn: ${Path.basename(txtFilePath)})`);

		// check and maybe error
		(() => {
			if (this._shouldWrite) {
				console.error("newTxtStreamAndMaybeLoadUserPiano() was called but this._shouldWrite was already true");
			}
			if (this._txtWriteStream != undefined) {
				console.error("newTxtStreamAndMaybeLoadUserPiano() was called but this._txtWriteStream was NOT undefined (should have been)");
			}

			if (!txtFilePath.endsWith('.txt')) {
				console.error(`newTxtStreamAndMaybeLoadUserPiano(), txtFilePath doesnt end with .txt. txtFilePath: ${txtFilePath}`);
			}
			if (txtFilePath.lastIndexOf('.txt') != txtFilePath.indexOf('.txt')) {
				console.error(`newTxtStreamAndMaybeLoadUserPiano(), txtFilePath has multiple .txt: ${txtFilePath}`);
			}
			if (!WebMidi.enabled)
				console.error(`newTxtStreamAndMaybeLoadUserPiano(), WebMidi.enabled == false`);


		})();


		let exists = await path_exists(txtFilePath);
		if (exists) {
			throw new Error(`newTxtStreamAndMaybeLoadUserPiano() txtFilePath exists. ${txtFilePath}`);
		}
		this._shouldWrite = true;
		console.log(`\t[${this.name}] this._userPiano is ${this._userPiano._loaded
		                                                   ? 'loaded (good)'
		                                                   : 'NOT loaded (not good, blockingMixin)'}`);
		if (!this._userPiano._loaded) {
			console.log("big blocking piano loading mixin");
			await blockingSwalMixin.fire({
				title: 'Loading piano',
				text: 'Please wait a few seconds...',
				onBeforeOpen: () => {
					blockingSwalMixin.showLoading();
				},
				onOpen: async modal => {
					this._userPiano.progress(prog => console.log(`\tðŸŽ¹ prog: ${prog}`));
					await this._userPiano.load();
					const $modal = $(modal);
					$modal.find('#swal2-title').text('Load complete');
					$modal.find('#swal2-content').text('Start playing!');
					await $fadeOut($modal.find('.swal2-loading'), 300);
					await wait(300);
					modal.classList.add('fadeOutUp', 'faster');
					await wait(500);
					blockingSwalMixin.close();
				},


			});

			console.log(`\tdone loading userPiano`);
		}

		this._txtWriteStream = await fs.createWriteStream(txtFilePath, {
			flags: 'w',
			encoding: 'utf8',
		});

		console.log(`\t[${this.name}] done awaiting fs.createWriteStream (${Path.basename(txtFilePath)})`);
		return txtFilePath;

	}

	_playNoteAndMaybeWriteTxt(note, velocity) {


		if (!this._shouldWrite || !this._userPiano._loaded) {
			let error = '_playNoteAndMaybeWriteTxt()';

			if (!this._shouldWrite)
				error += ', !this._shouldWrite';
			if (!this._userPiano._loaded) {
				error += ', !this._userPiano._loaded';


				if (!Swal.isVisible())
					Alert.small.warning("Piano isn't loaded. Have you pressed the big button?");
			}
			console.error(`\t${error}. returning`);
			return;
		}
		if (this._shouldWrite) {
			let ts = new Date() / 1000;
			this._txtWriteStream.write(`${ts}\tnote=${note}\tvelocity=${round(velocity * 127)}\n`);

		}
		let time = Tone.now();
		this._userPiano.keyDown(note, time, velocity);
	}

	_releaseNote(note, velocity) {
		if (!this._userPiano._loaded) {
			console.error('\t_releaseNote(), !this._userPiano._loaded. returning');
			return;
		}
		let time = Tone.now();
		this._userPiano.keyUp(note, time, velocity);
	}

	/**
	 @param {String} midiFilePath
	 @param {Animation?} [animation=null]
	 @param {Number?} [numOfNotes=null]
	 @param {Number?} [speed=null]
	 @param {Array?} [mistakes=null]
	 @param {Tone.AudioNode|Piano} playbackPiano
	 @return {Promise}
	 */
	async playMidiFile({ midiFilePath, animation, numOfNotes, speed, mistakes, playbackPiano }) {
		console.log(`ðŸŽ¹ [${this.name}] playMidiFile(), using playbackPiano: [${playbackPiano.name}]`, {
			midiFilePath,
			animation,
			numOfNotes,
			speed,
			mistakes,
			playbackPiano
		});

		if (!playbackPiano)
			return new Error(`\t[${this.name}] passed no playbackPiano`);
		if (!playbackPiano._loaded) {
			console.log(`\tðŸŽ¹ [${this.name}].playMidiFile() passed playbackPiano was NOT loaded (shouldn't happen)`);
			Alert.small.info('Loading piano', 'might take a few seconds...');
			await playbackPiano.load();
			console.log(`\tðŸŽ¹ [${this.name}].playMidiFile() done loading passed (unloaded) playbackPiano (shouldn't happen)`);
		}
		let midiRead = await MidiConvert.load(midiFilePath);

		return new Promise(async resolve => {


			Transport.bpm.value = midiRead.bpm;

			Transport.timeSignature = midiRead.timeSignature;
			Transport.start();

			let readTrack = midiRead.tracks.find(t => t.instrumentNumber == 0 && !t.notes.isEmpty());


			const scheduleNoteOn = (onTime, onEvent) => {
				let { midi, time, velocity, duration } = onEvent;
				playbackPiano.keyDown(midi, time, velocity);

				if (!animation)
					return;

				let fill = 'green';
				if (mistakes) {
					let index = noteOns.indexOf(onEvent);
					if (bool(mistakes[index])) {
						fill = 'red';
					}
				}
				let noteDuration = duration * 1000;
				animation.markKey(midi, noteDuration, fill);

			};

			const scheduleNoteOff = (offTime, offEvent) => {
				let index = noteOffs.indexOf(offEvent);
				playbackPiano.keyUp(offEvent.midi, offEvent.time, offEvent.velocity);
				if (index == noteOffs.length - 1) {
					Transport.stop();
					offPart.dispose();
					onPart.dispose();
					playbackPiano.stopAll();

					return resolve(playbackPiano);

				}
			};

			// let sustain = new Tone.Part(schedulePedal, track.controlChanges[64]).start(0);

			let [noteOns, noteOffs] = this._sliceNotes(readTrack, numOfNotes, speed);
			// noinspection JSCheckFunctionSignatures
			let offPart = new Tone.Part(scheduleNoteOff, noteOffs).start(0);
			// noinspection JSCheckFunctionSignatures
			let onPart = new Tone.Part(scheduleNoteOn, noteOns).start(0);


		});

	}


	_sliceNotes(readTrack, numOfNotes, speed) {

		let noteOffs = readTrack.noteOffs;

		noteOffs = numOfNotes
		           ? noteOffs.slice(0, numOfNotes)
		           : noteOffs;
		let noteOns = readTrack.notes;
		noteOns = numOfNotes
		          ? noteOns.slice(0, numOfNotes)
		          : noteOns;

		// noteOns.forEach(n => n.duration -= 0.05);
		// noteOffs.forEach(n => n.time += 0.05);
		console.log({ noteOns, noteOffs });
		debugger;
		if (speed) {
			for (let [i, note] of enumerate(noteOns)) {
				noteOns[i].duration = note.duration / speed;
				noteOns[i].time = note.time / speed;
			}
			for (let [i, note] of enumerate(noteOffs)) {
				noteOffs[i].duration = note.duration / speed;
				noteOffs[i].time = note.time / speed;
			}

		}
		return [noteOns, noteOffs];
	}


	_enableWebMidi() {
		const _bindInput = inputDevice => {
			if (WebMidi.enabled) {
				WebMidi.addListener('disconnected', device => {
					Alert.big.warning({ title: 'Keyboard disconnected! Please turn it on again', text: 'Refresh after this popup disappears.' });
					console.error("DEVICE DISCONNECTED", device);
					if (device.input) {
						device.input.removeListener('noteOn');
						device.input.removeListener('noteOff');
						WebMidi.disable();
					}
				});
				inputDevice.addListener('noteon', 'all', event => {
					this._playNoteAndMaybeWriteTxt(event.note.number, event.velocity);
				});
				inputDevice.addListener('noteoff', 'all', event => {
					this._releaseNote(event.note.number, event.velocity);
				});

				inputDevice.addListener('controlchange', "all", event => {
					if (event.controller.name === 'holdpedal') {
						this.emit(event.value
						          ?
						          'pedalDown'
						          :
						          'pedalUp');
					}
				});
			} else {
				console.error('_bindInput(inputDevice), WebMidi.enabled == false', {
					inputDevice
				});
			}
		};
		if (WebMidi.enabled)
			console.error('ðŸŽ¹ _enableWebMidi() called from constructor, and was Webmidi.enabled!');
		else
			WebMidi.enable(err => {
				if (!err) {
					if (WebMidi.inputs) {
						for (const inputDevice of WebMidi.inputs) {
							_bindInput(inputDevice);
						}
					}

					WebMidi.addListener('connected', device => {
						console.log("ðŸŽ¹ WebMidi.addListener('connected'", device);
						if (device.input) {
							_bindInput(device.input);
						}

					});
				} else {
					console.error('ðŸŽ¹ Webmidi.enable() err!', {
						err
					});
				}

			});
	}


}


module.exports = { Midi, toMidiFromMessages, toTxtFromMidi };

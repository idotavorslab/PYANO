// **gilad/index.js
const Tone = require("tone");
const Transport = Tone.Transport;
const $ = require("jquery");
let { EStore } = require("pyano_local_modules/ext_libs");
let Piano = require("./Piano");
let events = require("events");
let Swal = require("sweetalert2");
const WebMidi = require("webmidi");

let { concurrent, remove_ext, wait, path_exists, $fadeOut } = require("pyano_local_modules/util");
const MidiConvert = require("midiconvert");


let TonejsMidi = require("@tonejs/midi");
let { Alert, blockingSwalMixin } = require("pyano_local_modules/util/Alert");

const fs = require('fs');
Tone.context.lookAhead = 0;
Tone.context.latencyHint = 'fastest';

function _isBadPath(path, ext) {
	const fullExt = `.${ext}`;
	let bad = false;
	if (!path.endsWith(fullExt)) {
		console.error(`Path doesnt end with .${ext}. path: ${path}`);
		bad = true;
	}
	if (path.lastIndexOf(fullExt) != path.indexOf(fullExt)) {
		console.error(`Path has multiple .${ext}: ${path}`);
		bad = true;
	}
	return bad;
}

/**@param {string} midiFilePath
 * @return {Promise<string[]>} [txtFilePath, txtFilePathOn, txtFilePathOff]*/
async function toTxtFromMidi(midiFilePath) {

	if (_isBadPath(midiFilePath, 'mid'))
		throw new Error(`Bad midi file path: ${midiFilePath}`);

	let midiRead = await MidiConvert.load(midiFilePath);

	let readTrack = midiRead.tracks.find(t => t.instrumentNumber == 0 &&
	                                          !t.notes.isEmpty());

	const filePathNoExt = remove_ext(midiFilePath);
	const txtFilePathOn = `${filePathNoExt}_on.txt`;
	const txtFilePathOff = `${filePathNoExt}_off.txt`;
	const txtFilePath = `${filePathNoExt}.txt`;
	let [onExists, offExists, baseExists] = await concurrent(
		path_exists(txtFilePathOn),
		path_exists(txtFilePathOff),
		path_exists(txtFilePath));

	if (any(onExists, offExists, baseExists)) {
		throw new Error(`toTxtFromMidi() at least one txt file destination exists. Base path: ${txtFilePath}.
		onExists: ${onExists}, offExists: ${offExists}, baseExists: ${baseExists}`);
	}

	let txtWriteStreamOn = await fs.createWriteStream(txtFilePathOn, {
		flags: 'w',
		encoding: 'utf8',
	});
	let ts = new Date() / 1000;
	const noteOns = readTrack.notes;
	for (let noteOn of noteOns) {
		const on = `${round(ts + noteOn.time, 5)}\tnote=${noteOn.midi}\tvelocity=${round(noteOn.velocity * 127)}\ton\n`;
		txtWriteStreamOn.write(on);
	}

	txtWriteStreamOn.end();

	let txtWriteStreamOff = await fs.createWriteStream(txtFilePathOff, {
		flags: 'w',
		encoding: 'utf8',
	});
	const noteOffs = readTrack.noteOffs;
	for (let noteOff of noteOffs) {
		const off = `${round(ts + noteOff.time, 5)}\tnote=${noteOff.midi}\tvelocity=999\toff\n`;
		txtWriteStreamOff.write(off);
	}
	txtWriteStreamOff.end();

	return [txtFilePath, txtFilePathOn, txtFilePathOff];

}

/**
 @param {[TMessage[]]} on_off_pairs
 @param {Truth} truth
 */
async function toMidiFromMessages(on_off_pairs, truth) {


	if (await truth.midi.exists())
		return Promise.reject(`midi file exists: ${truth.midi}`);
	if (!(await truth.txt.allExist()))
		return Promise.reject(`not all txt file exist: ${truth.txt.base}`);
	let midiWrite = new TonejsMidi();
	midiWrite.addTrack();


	const firstMsgTime = on_off_pairs[0][0].time - 0.01;


	for (let [on_msg, off_msg] of on_off_pairs) {


		const onProps = {
			midi: on_msg.note,
			time: on_msg.time - firstMsgTime,
			velocity: on_msg.velocity / 127,
			noteOffVelocity: 1,
			duration: off_msg.time - on_msg.time,
		};

		midiWrite.tracks[0].addNote(onProps);
	}


	await fs.writeFile(truth.midi.path, new Buffer(midiWrite.toArray()), err => {
		if (err) throw err;
	});
}

/**@param {playMidiFileOptions} options
 @return {Promise<Piano>}*/
async function playMidiFile(options) {
	let { truth, animation, numOfNotes, speed, mistakes, playbackPiano } = options;
	console.log(`playMidiFile(), using playbackPiano: [${playbackPiano.name}]`, ...options);

	if (!playbackPiano)
		return Promise.reject(`\tpassed no playbackPiano`);
	if (!playbackPiano._loaded) {
		console.log(`\tplayMidiFile() passed playbackPiano was NOT loaded (shouldn't happen)`);
		Alert.small.info('Loading piano', 'might take a few seconds...');
		await playbackPiano.load();
		console.log(`\tplayMidiFile() done loading passed (unloaded) playbackPiano (shouldn't happen)`);
	}
	let midiRead = await MidiConvert.load(truth.midi.path);

	return new Promise(async resolve => {


		Transport.bpm.value = midiRead.bpm;

		Transport.timeSignature = midiRead.timeSignature;
		Transport.start();

		let readTrack = midiRead.tracks.find(t => t.instrumentNumber == 0 && !t.notes.isEmpty());


		const scheduleNoteOn = (onTime, onEvent) => {
			let { midi: note, time, velocity, duration } = onEvent;
			playbackPiano.keyDown(note, time, velocity);

			if (!animation)
				return;

			let fill = 'green';
			if (mistakes) {
				let index = noteOns.indexOf(onEvent);
				if (bool(mistakes[index])) {
					fill = 'red';
				}
			}
			let noteDuration = duration * 1000;
			animation.markKey(note, noteDuration, fill);

		};

		const scheduleNoteOff = (offTime, offEvent) => {
			let index = noteOffs.indexOf(offEvent);
			const { time, velocity, midi: note } = offEvent;
			playbackPiano.keyUp(note, time, velocity);
			if (index == noteOffs.length - 1) {
				Transport.stop();
				offPart.dispose();
				onPart.dispose();
				playbackPiano.stopAll();
				return resolve(playbackPiano);

			}
		};

		// let sustain = new Tone.Part(schedulePedal, track.controlChanges[64]).start(0);

		let [noteOns, noteOffs] = _sliceNotes(readTrack, numOfNotes, speed);

		// noinspection JSCheckFunctionSignatures
		let offPart = new Tone.Part(scheduleNoteOff, noteOffs).start(0);
		// noinspection JSCheckFunctionSignatures
		let onPart = new Tone.Part(scheduleNoteOn, noteOns).start(0);


	});

}

function _sliceNotes(readTrack, numOfNotes, speed) {

	let noteOffs = readTrack.noteOffs;

	noteOffs = numOfNotes
	           ? noteOffs.slice(0, numOfNotes)
	           : noteOffs;
	let noteOns = readTrack.notes;
	noteOns = numOfNotes
	          ? noteOns.slice(0, numOfNotes)
	          : noteOns;

	// noteOns.forEach(n => n.duration -= 0.05);
	// noteOffs.forEach(n => n.time += 0.05);
	console.log('\t_sliceNotes()', { noteOns, noteOffs });
	if (speed) {
		for (let [i, note] of enumerate(noteOns)) {
			noteOns[i].duration = note.duration / speed;
			noteOns[i].time = note.time / speed;
		}
		for (let [i, note] of enumerate(noteOffs)) {
			noteOffs[i].duration = note.duration / speed;
			noteOffs[i].time = note.time / speed;
		}

	}
	return [noteOns, noteOffs];
}


class Midi extends events.EventEmitter {
	/**@param {string} name
	 @param {Boolean?} muteUserPiano*/
	constructor({ name, muteUserPiano = true }) {
		super();
		this.name = name;
		this._shouldWrite = false;
		/**@type {WriteStream}*/
		this._onTxtWriteStream = undefined;
		/**@type {WriteStream}*/
		this._offTxtWriteStream = undefined;


		/**@type {Piano}*/
		this._userPiano = new Piano(`file:///${EStore.salamanderDirPath()}`, name, [21, 108], 5).toMaster();
		// Alert.small.info('Loading piano in the background', 'You can still use the page while it does');
		this._userPiano.load();
		let volume = muteUserPiano
		             ? -Infinity
		             : 0;
		console.log(`ðŸŽ¹ [${this.name}]`, { volume, name, muteUserPiano });
		this._userPiano.setVolume('note', volume);
		this._enableWebMidi();

		this.on('keyDown', (note, velocity) => {
			console.warn(`[${this.name}] this on keyDown`);
			this._playNoteAndMaybeWriteTxt(note, velocity);
		});

		this.on('keyUp', (note, velocity) => {
			console.warn(`[${this.name}] this on keyUp`);
			this._releaseNoteAndMaybeWriteTxt(note, velocity);
		});

		this.on('pedalDown', () => {
			this._userPiano.pedalDown();
		});

		this.on('pedalUp', () => {
			this._userPiano.pedalUp();
		});

	}


	/**
	 @param {[TMessage[]]} on_off_pairs
	 @param {Truth} truth*/
	async endOnOffTxtStreamsAndWriteMidi(on_off_pairs, truth) {
		console.log(`ðŸŽ¹ [${this.name}] endOnOffTxtStreamsAndWriteMidi(${truth.name})`);
		// check private members and throw
		(() => {
			if (!this._shouldWrite) {
				console.error("endOnOffTxtStreamsAndWriteMidi() this._shouldWrite was NOT true");
			}
			if (this._onTxtWriteStream == undefined) {
				console.error("endOnOffTxtStreamsAndWriteMidi() this._onTxtWriteStream WAS undefined (should not have been)");
			}
			if (this._offTxtWriteStream == undefined) {
				console.error("endOnOffTxtStreamsAndWriteMidi() this._offTxtWriteStream WAS undefined (should not have been)");
			}
			if (!WebMidi.enabled)
				console.error(`endOnOffTxtStreamsAndWriteMidi(), WebMidi.enabled == false`);

		})();

		this._shouldWrite = false;
		this._onTxtWriteStream.end();
		this._onTxtWriteStream = undefined;
		this._offTxtWriteStream.end();
		this._offTxtWriteStream = undefined;
		await toMidiFromMessages(on_off_pairs, truth);

	}

	/**
	 @param {Truth} truth
	 @return {Promise<Truth>}
	 */
	async newOnOffTxtWriteStreams(truth) {
		console.log(`ðŸŽ¹ [${this.name}] newOnOffTxtWriteStreams(${truth.name})`);

		// check and maybe error
		(() => {
			if (this._shouldWrite) {
				console.error("newOnOffTxtWriteStreams() was called but this._shouldWrite was already true");
			}
			if (this._onTxtWriteStream != undefined) {
				console.error("newOnOffTxtWriteStreams() was called but this._onTxtWriteStream was NOT undefined (should have been)");
			}
			if (this._offTxtWriteStream != undefined) {
				console.error("newOnOffTxtWriteStreams() was called but this._offTxtWriteStream was NOT undefined (should have been)");
			}

			if (!WebMidi.enabled)
				console.error(`newOnOffTxtWriteStreams(), WebMidi.enabled == false`);

		})();

		if (any(await asx.concurrent(
			truth.txt.base.exists(),
			truth.txt.on.exists(),
			truth.txt.off.exists()))) {
			return Promise.reject(`some txt files exist of truth: "${truth.txt.base.name}"`);
		}
		this._shouldWrite = true;
		console.log(`\t[${this.name}] this._userPiano is ${this._userPiano._loaded
		                                                   ? 'loaded (good)'
		                                                   : 'NOT loaded (not good, blockingMixin)'}`);
		if (!this._userPiano._loaded) {
			console.log("\nbig blocking piano loading mixin");
			await blockingSwalMixin.fire({
				title: 'Loading piano',
				text: 'Please wait a few seconds...',
				onBeforeOpen: () => blockingSwalMixin.showLoading(),
				onOpen: async modal => {
					this._userPiano.progress(prog => console.log(`\tðŸŽ¹ prog: ${prog}`));
					await this._userPiano.load();
					const $modal = $(modal);
					$modal.find('#swal2-title').text('Load complete');
					$modal.find('#swal2-content').text('Start playing!');
					await $fadeOut($modal.find('.swal2-loading'), 300);
					await wait(300);
					modal.classList.add('fadeOutUp', 'faster');
					await wait(500);
					blockingSwalMixin.close();
				},


			});

			console.log(`\tdone loading _userPiano`);
		}

		this._onTxtWriteStream = await fs.createWriteStream(truth.txt.on.path, {
			flags: 'w',
			encoding: 'utf8',
		});
		this._offTxtWriteStream = await fs.createWriteStream(truth.txt.off.path, {
			flags: 'w',
			encoding: 'utf8',
		});

		return truth;

	}

	_playNoteAndMaybeWriteTxt(note, velocity) {


		if (!this._shouldWrite || !this._userPiano._loaded) {
			let error = '_playNoteAndMaybeWriteTxt()';

			if (!this._shouldWrite)
				error += ', !this._shouldWrite';
			if (!this._userPiano._loaded) {
				error += ', !this._userPiano._loaded';


				if (!Swal.isVisible())
					Alert.small.warning("Piano isn't loaded. Have you pressed the big button?");
			}
			console.warn(`\t${error}. returning`);
			return;
		}
		if (this._shouldWrite) {
			let ts = new Date() / 1000;
			this._onTxtWriteStream.write(`${round(ts, 5)}\tnote=${note}\tvelocity=${round(velocity * 127)}\ton\n`);

		}
		let time = Tone.now();
		this._userPiano.keyDown(note, time, velocity);
	}

	_releaseNoteAndMaybeWriteTxt(note, velocity) {
		if (!this._shouldWrite || !this._userPiano._loaded) {
			let error = '_releaseNoteAndMaybeWriteTxt()';

			if (!this._shouldWrite)
				error += ', !this._shouldWrite';
			if (!this._userPiano._loaded) {
				error += ', !this._userPiano._loaded';


				if (!Swal.isVisible())
					Alert.small.warning("Piano isn't loaded. Have you pressed the big button?");
			}
			console.warn(`\t${error}. returning`);
			return;
		}
		if (this._shouldWrite) {
			let ts = new Date() / 1000;
			this._offTxtWriteStream.write(`${round(ts, 5)}\tnote=${note}\tvelocity=999\toff\n`);

		}
		let time = Tone.now();
		this._userPiano.keyUp(note, time, velocity);
	}


	/*async playMidiFile({ midiFilePath, animation, numOfNotes, speed, mistakes, playbackPiano }) {
		console.log(`ðŸŽ¹ [${this.name}] playMidiFile(), using playbackPiano: [${playbackPiano.name}]`, {
			midiFilePath,
			animation,
			numOfNotes,
			speed,
			mistakes,
			playbackPiano
		});

		if (!playbackPiano)
			return new Error(`\t[${this.name}] passed no playbackPiano`);
		if (!playbackPiano._loaded) {
			console.log(`\tðŸŽ¹ [${this.name}].playMidiFile() passed playbackPiano was NOT loaded (shouldn't happen)`);
			Alert.small.info('Loading piano', 'might take a few seconds...');
			await playbackPiano.load();
			console.log(`\tðŸŽ¹ [${this.name}].playMidiFile() done loading passed (unloaded) playbackPiano (shouldn't happen)`);
		}
		let midiRead = await MidiConvert.load(midiFilePath);

		return new Promise(async resolve => {


			Transport.bpm.value = midiRead.bpm;

			Transport.timeSignature = midiRead.timeSignature;
			Transport.start();

			let readTrack = midiRead.tracks.find(t => t.instrumentNumber == 0 && !t.notes.isEmpty());


			const scheduleNoteOn = (onTime, onEvent) => {
				let { midi, time, velocity, duration } = onEvent;
				playbackPiano.keyDown(midi, time, velocity);

				if (!animation)
					return;

				let fill = 'green';
				if (mistakes) {
					let index = noteOns.indexOf(onEvent);
					if (bool(mistakes[index])) {
						fill = 'red';
					}
				}
				let noteDuration = duration * 1000;
				animation.markKey(midi, noteDuration, fill);

			};

			const scheduleNoteOff = (offTime, offEvent) => {
				let index = noteOffs.indexOf(offEvent);

				playbackPiano.keyUp(offEvent.midi, offEvent.time, offEvent.velocity);
				if (index == noteOffs.length - 1) {
					Transport.stop();
					// offPart.dispose();
					// onPart.dispose();
					// playbackPiano.stopAll();
					return resolve(playbackPiano);

				}
			};

			// let sustain = new Tone.Part(schedulePedal, track.controlChanges[64]).start(0);

			let [noteOns, noteOffs] = this._sliceNotes(readTrack, numOfNotes, speed);

			// noinspection JSCheckFunctionSignatures
			let offPart = new Tone.Part(scheduleNoteOff, noteOffs).start(0);
			// noinspection JSCheckFunctionSignatures
			let onPart = new Tone.Part(scheduleNoteOn, noteOns).start(0);


		});

	}
	*/


	/*_sliceNotes(readTrack, numOfNotes, speed) {

		let noteOffs = readTrack.noteOffs;

		noteOffs = numOfNotes
		           ? noteOffs.slice(0, numOfNotes)
		           : noteOffs;
		let noteOns = readTrack.notes;
		noteOns = numOfNotes
		          ? noteOns.slice(0, numOfNotes)
		          : noteOns;

		// noteOns.forEach(n => n.duration -= 0.05);
		// noteOffs.forEach(n => n.time += 0.05);
		console.log({ noteOns, noteOffs });
		if (speed) {
			for (let [i, note] of enumerate(noteOns)) {
				noteOns[i].duration = note.duration / speed;
				noteOns[i].time = note.time / speed;
			}
			for (let [i, note] of enumerate(noteOffs)) {
				noteOffs[i].duration = note.duration / speed;
				noteOffs[i].time = note.time / speed;
			}

		}
		return [noteOns, noteOffs];
	}
	*/


	_enableWebMidi() {
		const _bindInput = inputDevice => {
			if (WebMidi.enabled) {
				WebMidi.addListener('disconnected', device => {
					Alert.big.warning({ title: 'Keyboard disconnected! Please turn it on again', text: 'Refresh after this popup disappears.' });
					console.error("DEVICE DISCONNECTED", device);
					if (device.input) {
						device.input.removeListener('noteOn');
						device.input.removeListener('noteOff');
						WebMidi.disable();
					}
				});
				inputDevice.addListener('noteon', 'all', event => {
					this._playNoteAndMaybeWriteTxt(event.note.number, event.velocity);
				});
				inputDevice.addListener('noteoff', 'all', event => {
					this._releaseNoteAndMaybeWriteTxt(event.note.number, event.velocity);
				});

				inputDevice.addListener('controlchange', "all", event => {
					if (event.controller.name === 'holdpedal') {
						this.emit(event.value
						          ?
						          'pedalDown'
						          :
						          'pedalUp');
					}
				});
			} else {
				console.error('_bindInput(inputDevice), WebMidi.enabled == false', {
					inputDevice
				});
			}
		};
		if (WebMidi.enabled)
			console.error('ðŸŽ¹ _enableWebMidi() called from constructor, and was Webmidi.enabled!');
		else
			WebMidi.enable(err => {
				if (!err) {
					if (WebMidi.inputs) {
						for (const inputDevice of WebMidi.inputs) {
							_bindInput(inputDevice);
						}
					}

					WebMidi.addListener('connected', device => {
						console.log("ðŸŽ¹ WebMidi.addListener('connected'", device);
						if (device.input) {
							_bindInput(device.input);
						}

					});
				} else {
					console.error('ðŸŽ¹ Webmidi.enable() err!', {
						err
					});
				}

			});
	}


}


module.exports = { Midi, toMidiFromMessages, toTxtFromMidi, playMidiFile };

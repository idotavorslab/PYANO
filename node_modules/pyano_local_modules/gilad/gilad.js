// **gilad/index.js
const Tone = require("tone");
const Transport = Tone.Transport;
const $ = require("jquery");
let { EStore } = require("pyano_local_modules/ext_libs");
let Piano = require("./Piano");
let events = require("events");
let Swal = require("sweetalert2");
let WebMidi = require("webmidi");
let { wait, replace_to_ext, bool, enumerate, round, max, Log, path_exists, $fadeOut } = require("pyano_local_modules/util");
const MidiConvert = require("midiconvert");


let TonejsMidi = require("@tonejs/midi");
let { Alert, blockingSwalMixin } = require("pyano_local_modules/util/Alert");

const fs = require('fs');
Tone.context.lookAhead = 0;
Tone.context.latencyHint = 'fastest';

function _isBadPath(path, ext) {
	const fullExt = `.${ext}`;
	let bad = false;
	if (!path.endsWith(fullExt)) {
		console.error(`Path doesnt end with .txt. path: ${path}`);
		bad = true;
	}
	if (path.lastIndexOf(fullExt) != path.indexOf(fullExt)) {
		console.error(`Path has multiple .txt: ${path}`);
		bad = true;
	}
	return bad;
}

/**@param {String} midiFilePath*/
async function toTxtFromMidi(midiFilePath) {

	if (_isBadPath(midiFilePath, 'mid'))
		throw new Error(`Bad midi file path: ${midiFilePath}`);

	let midiRead = await MidiConvert.load(midiFilePath);
	let readTrack = midiRead.tracks.find(t => t.instrumentNumber == 0 &&
	                                          !t.notes.isEmpty());


	const txtFilePath = replace_to_ext(midiFilePath, 'txt');
	let exists = await path_exists(txtFilePath);
	if (exists) {
		throw new Error(`toTxtFromMidi() txtFilePath exists. ${txtFilePath}`);

	}

	let txtWriteStream = await fs.createWriteStream(txtFilePath, {
		flags: 'w',
		encoding: 'utf8',
	});
	let ts = new Date() / 1000;
	for (let note of readTrack.notes) {
		let {
			midi,
			time,
			velocity,
			duration
		} = note;
		txtWriteStream.write(`${ts + time}\tnote=${midi}\tvelocity=${round(velocity * 127)}\tduration=${duration}\n`);
	}

	txtWriteStream.end();


}

/**
 @param {TMessage[]} messages
 @param {String} midiFilePath
 */
async function toMidiFromMessages(messages, midiFilePath) {
	if (_isBadPath(midiFilePath, 'mid'))
		throw new Error(`Bad midi file path: ${midiFilePath}`);

	let exists = await path_exists(midiFilePath);
	if (exists) {
		throw new Error(`toMidiFromMessages() midiFilePath exists. ${midiFilePath}`);
	}
	let midiWrite = new TonejsMidi();
	midiWrite.addTrack();

	const firstMsgTime = messages[0].time - 0.01;
	for (let [i, msg] of enumerate(messages)) {
		if (i == 0)
			continue;

		let previousMsg = messages[i - 1];
		midiWrite.tracks[0].addNote({
			midi: previousMsg.note,
			time: previousMsg.time - firstMsgTime,
			velocity: previousMsg.velocity / 127,
			noteOffVelocity: previousMsg.velocity / 127,
			duration: max(msg.time_delta, 0.3),
		});
	}
	let lastMsg = messages.last();
	midiWrite.tracks[0].addNote({
		midi: lastMsg.note,
		time: lastMsg.time - firstMsgTime,
		velocity: lastMsg.velocity / 127,
		noteOffVelocity: lastMsg.velocity / 127,
		duration: 1,
	});

	await fs.writeFile(midiFilePath, new Buffer(midiWrite.toArray()), err => {
		if (err) throw err;
	});
}

class Midi extends events.EventEmitter {
	/**@param {Boolean?} muteUserPiano*/
	constructor({ muteUserPiano = true }) {
		super();

		this._shouldWrite = false;
		/**@type {WriteStream}*/
		this._txtWriteStream = undefined;


		/**@type {Piano|Tone.AudioNode}*/
		this._userPiano = new Piano(`file:///${EStore.salamanderDirPath()}`, [21, 108], 5).toMaster();
		Alert.small.info('Loading piano in the background', 'You can still use the page while it does');
		this._userPiano.load();
		let volume = muteUserPiano
		             ? -Infinity
		             : 0;
		console.log(`volume: ${volume}`);
		this._userPiano.setVolume('note', volume);
		this._enableWebMidi();

		this.on('keyDown', (note, velocity) => {
			console.warn("this on keyDown");
			this._playNoteAndMaybeWriteTxt(note, velocity);
		});

		this.on('keyUp', (note, velocity) => {
			console.warn("this on keyUp");
			this._releaseNote(note, velocity);
		});


		this.on('pedalDown', () => {
			this._userPiano.pedalDown();
		});

		this.on('pedalUp', () => {
			this._userPiano.pedalUp();
		});

	}


	get Convert() {
		const _convert = {
			/*async toTxtFromMidi(midiFilePath) {

				if (_isBadPath(midiFilePath, 'mid'))
					throw new Error(`Bad midi file path: ${midiFilePath}`);

				let midiRead = await MidiConvert.load(midiFilePath);
				let readTrack = midiRead.tracks.find(t => t.instrumentNumber == 0 &&
				                                          !t.notes.isEmpty());


				const txtFilePath = replace_to_ext(midiFilePath, 'txt');
				let exists = await path_exists(txtFilePath);
				if (exists) {
					throw new Error(`toTxtFromMidi() txtFilePath exists. ${txtFilePath}`);

				}

				let txtWriteStream = await fs.createWriteStream(txtFilePath, {
					flags: 'w',
					encoding: 'utf8',
				});
				let ts = new Date() / 1000;
				for (let note of readTrack.notes) {
					let {
						midi,
						time,
						velocity,
						duration
					} = note;
					txtWriteStream.write(`${ts + time}\tnote=${midi}\tvelocity=${round(velocity * 127)}\tduration=${duration}\n`);
				}

				txtWriteStream.end();


			},
			*/

			/*async toMidiFromMessages(messages, midiFilePath) {
				if (_isBadPath(midiFilePath, 'mid'))
					throw new Error(`Bad midi file path: ${midiFilePath}`);

				let exists = await path_exists(midiFilePath);
				if (exists) {
					throw new Error(`toMidiFromMessages() midiFilePath exists. ${midiFilePath}`);
				}
				let midiWrite = new TonejsMidi();
				midiWrite.addTrack();

				const firstMsgTime = messages[0].time - 0.01;
				for (let [i, msg] of enumerate(messages)) {
					if (i == 0)
						continue;

					let previousMsg = messages[i - 1];
					midiWrite.tracks[0].addNote({
						midi: previousMsg.note,
						time: previousMsg.time - firstMsgTime,
						velocity: previousMsg.velocity / 127,
						noteOffVelocity: previousMsg.velocity / 127,
						duration: max(msg.time_delta, 0.3),
					});
				}
				let lastMsg = messages.last();
				midiWrite.tracks[0].addNote({
					midi: lastMsg.note,
					time: lastMsg.time - firstMsgTime,
					velocity: lastMsg.velocity / 127,
					noteOffVelocity: lastMsg.velocity / 127,
					duration: 1,
				});

				await fs.writeFile(midiFilePath, new Buffer(midiWrite.toArray()), err => {
					if (err) throw err;
				});
			}
			*/
		};
		return _convert;
	}

	/**
	 @param {TMessage[]} messages
	 @param {String} midiFilePath*/
	async endTxtAndWriteMidi(messages, midiFilePath) {
		console.log('%cendTxtAndWriteMidi(midiFilePath)', 'font-weight:900', {
			midiFilePath
		});
		// check private members and throw
		(() => {
			if (!this._shouldWrite) {
				console.error("endTxtAndWriteMidi() this._shouldWrite was NOT true");
			}
			if (this._txtWriteStream == undefined) {
				console.error("endTxtAndWriteMidi() this._txtWriteStream WAS undefined (should not have been)");
			}

			if (!midiFilePath.endsWith('.mid')) {
				console.error(`endTxtAndWriteMidi(), midiFilePath doesnt end with .mid. midiFilePath: ${midiFilePath}`);
			}
			if (midiFilePath.lastIndexOf('.mid') != midiFilePath.indexOf('.mid')) {
				console.error(`endTxtAndWriteMidi(), midiFilePath has multiple .mid: ${midiFilePath}`);
			}
			if (!WebMidi.enabled)
				console.error(`endTxtAndWriteMidi(), WebMidi.enabled == false`);

		})();

		this._shouldWrite = false;
		this._txtWriteStream.end();
		this._txtWriteStream = undefined;

		await toMidiFromMessages(messages, midiFilePath);

	}

	/**
	 @param {String} txtFilePath
	 @return {Promise<String>}
	 */
	async newTxtStreamAndMaybeLoadUserPiano(txtFilePath) {
		console.log('%cnewTxtStreamAndMaybeLoadUserPiano(txtFilePath)', 'font-weight:900', {
			txtFilePath
		});

		// check and maybe error
		(() => {
			if (this._shouldWrite) {
				console.error("newTxtStreamAndMaybeLoadUserPiano() was called but this._shouldWrite was already true");
			}
			if (this._txtWriteStream != undefined) {
				console.error("newTxtStreamAndMaybeLoadUserPiano() was called but this._txtWriteStream was NOT undefined (should have been)");
			}

			if (!txtFilePath.endsWith('.txt')) {
				console.error(`newTxtStreamAndMaybeLoadUserPiano(), txtFilePath doesnt end with .txt. txtFilePath: ${txtFilePath}`);
			}
			if (txtFilePath.lastIndexOf('.txt') != txtFilePath.indexOf('.txt')) {
				console.error(`newTxtStreamAndMaybeLoadUserPiano(), txtFilePath has multiple .txt: ${txtFilePath}`);
			}
			if (!WebMidi.enabled)
				console.error(`newTxtStreamAndMaybeLoadUserPiano(), WebMidi.enabled == false`);
			/*if (bool(this._subjectNoteOns) || bool(this._subjectNoteOffs)) {
				console.error(`newTxtStreamAndMaybeLoadUserPiano(), noteOns or Offs not empty:`, {
					noteOns: this._subjectNoteOns,
					noteOffs: this._subjectNoteOffs
				});
			}
			if (this._subjectNoteOns.length != this._subjectNoteOffs.length) {
				console.error("newTxtStreamAndMaybeLoadUserPiano() note Ons and Offs have different lengths", {
					noteOns: this._subjectNoteOns,
					noteOffs: this._subjectNoteOffs
				});
			}
			*/

		})();


		let exists = await path_exists(txtFilePath);
		if (exists) {
			throw new Error(`newTxtStreamAndMaybeLoadUserPiano() txtFilePath exists. ${txtFilePath}`);
		}
		this._shouldWrite = true;
		console.log(`\tthis._userPiano IS ${this._userPiano._loaded
		                                    ? ''
		                                    : 'NOT'} loaded`);
		if (!this._userPiano._loaded) {
			console.log("big blocking piano loading mixin");
			await blockingSwalMixin.fire({
				title: 'Loading piano',
				text: 'Please wait a few seconds...',
				onBeforeOpen: () => {
					blockingSwalMixin.showLoading();
				},
				onOpen: async modal => {
					this._userPiano.progress(prog => console.log(`\tprog: ${prog}`));
					await this._userPiano.load();
					const $modal = $(modal);
					$modal.find('#swal2-title').text('Load complete');
					$modal.find('#swal2-content').text('Start playing!');
					await $fadeOut($modal.find('.swal2-loading'), 300);
					await wait(300);
					modal.classList.add('fadeOutUp', 'faster');
					await wait(500);
					blockingSwalMixin.close();
				},


			});

			console.log(`\tdone loading userPiano`);
		}

		this._txtWriteStream = await fs.createWriteStream(txtFilePath, {
			flags: 'w',
			encoding: 'utf8',
		});

		console.log('\tdone awaiting fs.createWriteStream');
		return txtFilePath;

	}

	_playNoteAndMaybeWriteTxt(note, velocity) {
		Log.yellow(`_playNoteAndMaybeWriteTxt()`);


		if (!this._shouldWrite || !this._userPiano._loaded) {
			let error = '_playNoteAndMaybeWriteTxt()';

			if (!this._shouldWrite)
				error += ', !this._shouldWrite';
			if (!this._userPiano._loaded) {
				error += ', !this._userPiano._loaded';


				if (!Swal.isVisible())
					Alert.small.warning("Piano isn't loaded. Have you pressed the big button?");
			}
			console.error(`\t${error}. returning`);
			return;
		}
		if (this._shouldWrite) {
			let ts = new Date() / 1000;
			this._txtWriteStream.write(`${ts}\tnote=${note}\tvelocity=${round(velocity * 127)}\n`);

		}
		let time = Tone.now();
		this._userPiano.keyDown(note, time, velocity);
	}

	_releaseNote(note, velocity) {
		Log.yellow('_releaseNote()');
		if (!this._userPiano._loaded) {
			console.error('\t_releaseNote(), !this._userPiano._loaded. returning');
			return;
		}
		let time = Tone.now();
		this._userPiano.keyUp(note, time, velocity);
	}

	/**
	 @param {String} midiFilePath
	 @param {Animation?} [animation=null]
	 @param {Number?} [numOfNotes=null]
	 @param {Number?} [speed=null]
	 @param {Array?} [mistakes=null]
	 @param {Tone.AudioNode|Piano} playbackPiano
	 @return {Promise}
	 */
	async playMidiFile({
		                   midiFilePath,
		                   animation,
		                   numOfNotes,
		                   speed,
		                   mistakes,
		                   playbackPiano
	                   }) {
		console.log('%cplayMidiFile()', 'font-weight:900', {
			midiFilePath,
			animation,
			numOfNotes,
			speed,
			mistakes,
			playbackPiano
		});

		if (!playbackPiano)
			console.error('\treceived no playbackPiano', {
				playbackPiano
			});
		if (!playbackPiano._loaded) {
			console.log('\tplaybackPiano was NOT loaded');
			Alert.small.info('Loading piano', 'might take a few seconds...');
			await playbackPiano.load();
			console.log(`\tdone loading playbackPiano`);
		}
		let midiRead = await MidiConvert.load(midiFilePath);
		return new Promise(async resolve => {


			Transport.bpm.value = midiRead.bpm;
			Transport.timeSignature = midiRead.timeSignature;
			Transport.start();

			let readTrack = midiRead.tracks.find(t => t.instrumentNumber == 0 && !t.notes.isEmpty());


			/*const playNote = (time, event) => {
				Log.blue(`playNote(time = ${time}, event = ${event})`);
				this._userPiano
				    .keyDown(event.note, time, event.velocity)
				    .keyUp(event.note, time + event.duration, 0);
			};
			const schedulePedal = (time, event) => {
				if (event.value) {
					this._userPiano.pedalDown(time);
				} else {
					this._userPiano.pedalUp(time);
				}
			};
			*/

			const scheduleNoteOn = (onTime, onEvent) => {
				let {
					midi,
					time,
					velocity,
					duration
				} = onEvent;
				playbackPiano.keyDown(midi, time, velocity);

				if (!animation)
					return;

				let fill = 'green';
				if (mistakes) {
					let index = noteOns.indexOf(onEvent);
					if (bool(mistakes[index])) {
						fill = 'red';
					}
				}
				let noteDuration = duration * 1000;
				animation.markKey(midi, noteDuration, fill);

			};

			const scheduleNoteOff = (offTime, offEvent) => {
				let index = noteOffs.indexOf(offEvent);
				playbackPiano.keyUp(offEvent.midi, offEvent.time, offEvent.velocity);
				if (index == noteOffs.length - 1) {
					Transport.stop();
					offPart.dispose();
					onPart.dispose();
					playbackPiano.stopAll();

					return resolve(playbackPiano);

				}
			};

			// let sustain = new Tone.Part(schedulePedal, track.controlChanges[64]).start(0);
			let [noteOns, noteOffs] = await this._sliceNotes(readTrack, numOfNotes, speed);
			// noinspection JSCheckFunctionSignatures
			let offPart = new Tone.Part(scheduleNoteOff, noteOffs).start(0);
			// noinspection JSCheckFunctionSignatures
			let onPart = new Tone.Part(scheduleNoteOn, noteOns).start(0);


		});

	}


	async _sliceNotes(readTrack, numOfNotes, speed) {

		let noteOffs = readTrack.noteOffs;

		noteOffs = numOfNotes
		           ?
		           noteOffs.slice(0, numOfNotes)
		           :
		           noteOffs;

		let noteOns = readTrack.notes;
		noteOns = numOfNotes
		          ?
		          noteOns.slice(0, numOfNotes)
		          :
		          noteOns;
		if (speed) {
			for (let [i, note] of enumerate(noteOns)) {
				noteOns[i].duration = note.duration / speed;
				noteOns[i].time = note.time / speed;
			}
			for (let [i, note] of enumerate(noteOffs)) {
				noteOffs[i].duration = note.duration / speed;
				noteOffs[i].time = note.time / speed;
			}

		}
		return [noteOns, noteOffs];
	}


	_enableWebMidi() {
		const _bindInput = inputDevice => {
			if (WebMidi.enabled) {
				WebMidi.addListener('disconnected', device => {
					Alert.big.warning('Keyboard disconnected! Please turn it on again', 'Refresh after this popup disappears.');
					console.error("DEVICE DISCONNECTED", device);
					if (device.input) {
						device.input.removeListener('noteOn');
						device.input.removeListener('noteOff');
						WebMidi.disable();
					}
				});
				inputDevice.addListener('noteon', 'all', event => {
					this._playNoteAndMaybeWriteTxt(event.note.number, event.velocity);
				});
				inputDevice.addListener('noteoff', 'all', event => {
					this._releaseNote(event.note.number, event.velocity);
				});

				inputDevice.addListener('controlchange', "all", event => {
					if (event.controller.name === 'holdpedal') {
						this.emit(event.value
						          ?
						          'pedalDown'
						          :
						          'pedalUp');
					}
				});
			} else {
				console.error('_bindInput(inputDevice), WebMidi.enabled == false', {
					inputDevice
				});
			}
		};
		if (WebMidi.enabled)
			console.error('_enableWebMidi() called from constructor, and was Webmidi.enabled!');
		else
			WebMidi.enable(err => {
				if (!err) {

					if (WebMidi.inputs) {
						for (const inputDevice of WebMidi.inputs) {
							_bindInput(inputDevice);
						}
					}

					WebMidi.addListener('connected', device => {
						console.log("WebMidi.addListener('connected'", device);
						if (device.input) {
							_bindInput(device.input);
						}

					});
				} else {
					console.error('Webmidi.enable() err!', {
						err
					});
				}

			});
	}


}


module.exports = { Midi, toMidiFromMessages,toTxtFromMidi };

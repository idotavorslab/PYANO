let Tone = require("tone");

let Pedal = require("./Pedal");

let Notes = require("./Notes");

let Harmonics = require("./Harmonics");

let Release = require("./Release");


/**
 *  @class Multisampled Grand Piano using [Salamander Piano Samples](https://archive.org/details/SalamanderGrandPianoV3)
 *  @extends {Tone}
 */
class Piano extends Tone.AudioNode {
	/**
	 @param {String} localSamplesPath - "file:///path/to/samples/" - must end with forward slash
	 @param {String} name
	 @param args
	 */
	constructor(localSamplesPath, name, ...args) {
		const options = Tone.defaults(args, ["range", "velocities"], {
			velocities: 1,
			range: [21, 108],
			release: false
		});
		super();
		this.createInsOuts(0, 1);
		this.name = name;
		console.log(`[${this.name}] options`, options);
		this._loaded = false;

		this._heldNotes = new Map();

		this._sustainedNotes = new Map();

		this._notes = new Notes(options.range, options.velocities).connect(this.output);

		this._pedal = new Pedal().connect(this.output);

		if (options.release) {
			this._harmonics = new Harmonics(options.range).connect(this.output);

			this._release = new Release(options.range).connect(this.output);
		}
		this._localSamplesPath = localSamplesPath;


	}

	/**
	 *  Load all the samples
	 *  @return  {Promise}
	 */
	async load(url = this._localSamplesPath) {
		const { concurrent } = require("pyano_local_modules/util");
		// load() {
		const promises = [this._notes.load(url)];
		if (this._harmonics) {
			promises.push(this._harmonics.load(url));
		}
		if (this._release) {
			promises.push(this._release.load(url));
		}
		// await this._notes.load(url);
		await concurrent(promises);
		console.log(`[${this.name}] %cPiano.js loaded`, 'color:#278b3e');
		this._loaded = true;
	}

	/**
	 * If all the samples are loaded or not
	 @readOnly
	 @type {Boolean}
	 */
	get loaded() {
		return this._loaded;
	}

	/**
	 *  Put the pedal down at the given time. Causes subsequent
	 *  notes and currently held notes to sustain.

	 *  @returns {Piano} this
	 */
	pedalDown(time = Tone.now()) {
		if (this.loaded) {
			if (this.toSeconds(time) != time) throw Error(`pedalDown this.toSeconds(time)!=time. this.toSeconds(time): ${this.toSeconds(time)}, time: ${time}`);
			if (!this._pedal.isDown(time)) {
				this._pedal.down(time);
			}
		}
		return this;
	}

	/**
	 *  Put the pedal up. Dampens sustained notes

	 *  @returns {Piano} this
	 */
	pedalUp(time = Tone.now()) {
		if (this.loaded) {
			if (this.toSeconds(time) != time) throw Error(`pedalUp this.toSeconds(time)!=time. this.toSeconds(time): ${this.toSeconds(time)}, time: ${time}`);
			if (this._pedal.isDown(time)) {
				this._pedal.up(time);
				// dampen each of the notes
				this._sustainedNotes.forEach((t, note) => {
					if (!this._heldNotes.has(note)) {
						this._notes.stop(note, time);
					}
				});
				this._sustainedNotes.clear();
			}
		}
		return this;
	}

	/**
	 *  Play a note.
	 *  @param  {String|Number}  note      The note to play. If it is a number, it is assumed
	 *                                     to be MIDI
	 *  @param  {NormalRange}  velocity  The velocity to play the note
	 *  @return  {Piano}  this
	 */
	keyDown(note, time = Tone.now(), velocity = 0.8) {
		if (!this.loaded) {
			console.error('Piano.keyDown() not this.loaded');
			return this;
		}
		if (this.toSeconds(time) != time) throw Error(`keyDown this.toSeconds(time)!=time. this.toSeconds(time): ${this.toSeconds(time)}, time: ${time}`);

		if (Tone.isString(note)) {
			note = Math.round(Tone.Frequency(note).toMidi());
		}
		if (!this._heldNotes.has(note)) {
			//record the start time and velocity
			this._heldNotes.set(note, { time, velocity });
			this._notes.start(note, time, velocity);
		}
		console.log(`[${this.name}] keyDown`, { note, time, velocity });
		return this;
	}

	/**
	 *  Release a held note.
	 *  @param  {String|Number}  note      The note to stop
	 *  @param {Number} time
	 *  @param {Number} velocity
	 *  @return  {Piano}  this
	 */
	keyUp(note, time = Tone.now(), velocity = 0.8) {
		if (!this.loaded) {
			console.log('Piano.keyUp() not this.loaded');
			return this;
		}
		if (this.toSeconds(time) != time) throw Error(`keyUp this.toSeconds(time)!=time. this.toSeconds(time): ${this.toSeconds(time)}, time: ${time}`);
		if (Tone.isString(note))
			note = Math.round(Tone.Frequency(note).toMidi());


		if (this._heldNotes.has(note)) {

			const prevNote = this._heldNotes.get(note);
			this._heldNotes.delete(note);

			if (this._release) {
				this._release.start(note, time, velocity);
				// this._release.start(note, time, 0);
			}

			//compute the release velocity
			const holdTime = time - prevNote.time;
			const prevVel = prevNote.velocity;
			let dampenGain = (0.5 / Math.max(holdTime, 0.1)) + prevVel + velocity;
			dampenGain = Math.pow(Math.log(Math.max(dampenGain, 1)), 2) / 2;

			if (this._pedal.isDown(time)) {

				if (!this._sustainedNotes.has(note)) {
					this._sustainedNotes.set(note, time);
				}
			} else {
				this._notes.stop(note, time, velocity);

				if (this._harmonics) {
					this._harmonics.start(note, time, dampenGain);
					// this._harmonics.start(note, time, 0);
				}
			}
		}
		console.log(`[${this.name}] keyUp`, { note, time, velocity });
		return this;

	}

	/**
	 Set the volumes of each of the components
	 @param {String} param
	 @param {Decibels|Number} vol
	 @return {Piano} this
	 @example
	 //either as an String
	 piano.setVolume('release', -10)
	 */
	setVolume(param, vol) {
		switch (param) {
			case 'note':
				this._notes.volume = vol;
				break;
			case 'pedal':
				this._pedal.volume = vol;
				break;
			case 'release':
				if (this._release) {
					this._release.volume = vol;
				}
				break;
			case 'harmonics':
				if (this._harmonics) {
					this._harmonics.volume = vol;
				}
				break;
		}
		return this;
	}

	/**@param value - between 0 and 1*/
	setReverb(value) {
		let reverb = new Tone.Freeverb(0.2, 3000).toMaster();
		reverb.wet.value = value;
		this.connect(reverb);
	}

	stopAll() {
		this.pedalUp();
		this._heldNotes.forEach((value, note) => {
			this.keyUp(note);
		});
		return this;
	}

	/**
	 Callback to invoke with normalized progress
	 @param  {Function} cb
	 */
	progress(cb) {
		Tone.Buffer.on('progress', cb);
		return this;
	}
}

module.exports = Piano;

let Tone = require("tone");
let Pedal = require("./Pedal");

let Notes = require("./Notes");

/*let Harmonics = require("./Harmonics");

let Release = require("./Release");
*/

/**@class*/
class Piano extends Tone.AudioNode {

	/**
	 @param {string} localSamplesPath - "file:///path/to/samples/" - must end with forward slash
	 @param {string} name
	 */
	constructor(localSamplesPath, name) {
		/*const options = Tone.defaults(args, ["range", "velocities"], {
			velocities: 12,
			range: [21, 108],
			release: false
		});
		*/
		/*const { EStore } = require("pyano_local_modules/ext_libs");
		let velocities = EStore.get('velocities');
		if (!(velocities && typeof velocities == "number" && 1 <= velocities && velocities <= 16)) // number between 1 and 16
			velocities = 1;
		*/
		const velocities = 1;
		const options = {
			velocities: velocities,
			range: [21, 108],
			release: false
		};
		super();
		this.createInsOuts(0, 1);
		this.name = name;
		console.log(`ðŸŽ¹ [${this.name}] options`, options);
		this._loaded = false;

		this._heldNotes = new Map();

		this._sustainedNotes = new Map();

		this._notes = new Notes(options.range, options.velocities).connect(this.output);

		this._pedal = new Pedal().connect(this.output);

		/*if (options.release) {
			this._harmonics = new Harmonics(options.range).connect(this.output);

			this._release = new Release(options.range).connect(this.output);
		}
		*/
		this._localSamplesPath = localSamplesPath;


	}

	/**
	 *  Load all the samples
	 *  @return  {Promise}
	 */
	async load(url = this._localSamplesPath) {
		/*const promises = [this._notes.load(url)];
		if (this._harmonics) {
			promises.push(this._harmonics.load(url));
		}
		if (this._release) {
			promises.push(this._release.load(url));
		}
		await asx.concurrent(promises);
		*/
		await this._notes.load(url);
		console.log(`ðŸŽ¹ [${this.name}] %cPiano.js loaded`, 'color:#278b3e; font-size:10px');
		this._loaded = true;
		return true;
	}

	/**
	 * If all the samples are loaded or not
	 @readOnly
	 @type {boolean}
	 */
	get loaded() {
		return this._loaded;
	}

	/**
	 *  Put the pedal down at the given time. Causes subsequent
	 *  notes and currently held notes to sustain.

	 *  @returns {Piano} this
	 */
	pedalDown(time = Tone.now()) {
		if (this.loaded) {
			if (this.toSeconds(time) != time) throw Error(`pedalDown this.toSeconds(time)!=time. this.toSeconds(time): ${this.toSeconds(time)}, time: ${time}`);
			if (!this._pedal.isDown(time)) {
				this._pedal.down(time);
			}
		}
		return this;
	}

	/**
	 *  Put the pedal up. Dampens sustained notes

	 *  @returns {Piano} this
	 */
	pedalUp(time = Tone.now()) {
		if (this.loaded) {
			if (this.toSeconds(time) != time) throw Error(`pedalUp this.toSeconds(time)!=time. this.toSeconds(time): ${this.toSeconds(time)}, time: ${time}`);
			if (this._pedal.isDown(time)) {
				this._pedal.up(time);
				// dampen each of the notes
				this._sustainedNotes.forEach((t, note) => {
					if (!this._heldNotes.has(note)) {
						this._notes.stop(note, time);
					}
				});
				this._sustainedNotes.clear();
			}
		}
		return this;
	}

	/**
	 *  Play a note.
	 *  @param  {string|number}  note      The note to play. If it is a number, it is assumed
	 *                                     to be MIDI
	 *  @param  {NormalRange}  velocity  The velocity to play the note
	 *  @return  {Piano}  this
	 */
	keyDown(note, time = Tone.now(), velocity = 0.8) {
		if (!this.loaded) {
			console.error('ðŸŽ¹ Piano.keyDown() not this.loaded');
			return this;
		}
		if (this.toSeconds(time) != time) throw Error(`keyDown this.toSeconds(time)!=time. this.toSeconds(time): ${this.toSeconds(time)}, time: ${time}`);

		if (Tone.isString(note)) {
			note = Math.round(Tone.Frequency(note).toMidi());
		}

		if (!this._heldNotes.has(note)) {
			//record the start time and velocity
			this._heldNotes.set(note, { time, velocity });
			this._notes.start(note, time, velocity);
		}

		// console.log(`[${this.name}] keyDown`, { note, time, velocity });
		return this;
	}

	/**
	 *  Release a held note.
	 *  @param  {string|number}  note      The note to stop
	 *  @param {number} time
	 *  @param {number} velocity
	 *  @return  {Piano}  this
	 */
	keyUp(note, time = Tone.now(), velocity = 0.8) {
		if (!this.loaded) {
			console.log('ðŸŽ¹ Piano.keyUp() not this.loaded');
			return this;
		}
		if (this.toSeconds(time) != time) throw Error(`keyUp this.toSeconds(time)!=time. this.toSeconds(time): ${this.toSeconds(time)}, time: ${time}`);
		if (Tone.isString(note))
			note = Math.round(Tone.Frequency(note).toMidi());


		if (this._heldNotes.has(note)) {

			const prevNote = this._heldNotes.get(note);
			this._heldNotes.delete(note);

			/*if (this._release) {
				this._release.start(note, time, velocity);
				// this._release.start(note, time, 0);
			}
			*/

			//compute the release velocity
			const holdTime = time - prevNote.time;
			const prevVel = prevNote.velocity;
			let dampenGain = (0.5 / Math.max(holdTime, 0.1)) + prevVel + velocity;
			dampenGain = Math.pow(Math.log(Math.max(dampenGain, 1)), 2) / 2;

			if (this._pedal.isDown(time)) {

				if (!this._sustainedNotes.has(note)) {
					this._sustainedNotes.set(note, time);
				}
			} else {
				this._notes.stop(note, time, velocity);

				/*if (this._harmonics) {
					this._harmonics.start(note, time, dampenGain);
					// this._harmonics.start(note, time, 0);
				}
				*/
			}
		}
		// console.log(`[${this.name}] keyUp`, { note, time, velocity });
		return this;

	}

	/**
	 Set the volumes of each of the components
	 @param {string} param
	 @param {Decibels|number} vol
	 @return {Piano} this
	 @example
	 //either as an String
	 piano.setVolume('release', -10)
	 */
	setVolume(param, vol) {
		switch (param) {
			case 'note':
				this._notes.volume = vol;
				break;
			case 'pedal':
				this._pedal.volume = vol;
				break;
			/*case 'release':
				if (this._release) {
					this._release.volume = vol;
				}
				break;
			case 'harmonics':
				if (this._harmonics) {
					this._harmonics.volume = vol;
				}
				break;
			*/
		}
		return this;
	}

	/**@param value - between 0 and 1*/
	setReverb(value) {
		let reverb = new Tone.Freeverb(0.2, 3000).toMaster();
		reverb.wet.value = value;
		this.connect(reverb);
	}

	stopAll() {
		this.pedalUp();
		this._heldNotes.forEach((value, note) => {
			this.keyUp(note);
		});
		return this;
	}

	/**
	 Callback to invoke with normalized progress
	 @param  {Function} cb
	 */
	progress(cb) {
		Tone.Buffer.on('progress', cb);
		return this;
	}
}

/**
 * @type {Piano}
 */
module.exports = Piano;

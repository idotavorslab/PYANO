class Messages {
	/**@param {TMessage[]} msgs*/
	constructor(msgs) {
		/**@type {TMessage[]}*/
		this._msgs = msgs;
	}

	/**@return {Object<Number,Number[]>}*/
	chords() {
		const { bool, enumerate } = require("pyano_local_modules/util");
		let chords = {};
		for (let [i, message] of enumerate(this._msgs)) {
			if (message.time_delta == null) continue;
			if (message.time_delta <= 0.05) {
				if (!bool(chords)) {
					chords[i - 1] = [i];
					continue;
				}
				let last_key = Object.keys(chords).last();
				/**@type {Number[]}*/
				let last_value = chords[last_key];

				if (last_key == i - 1 || last_value.includes(i - 1)) {
					chords[last_key].push(i);
				} else {
					chords[i - 1] = [i];
				}
			}
		}
		return chords;
	}

	_numofChordedNotes(upTo) {
		let numofChordedNotes = 0;
		let chords = this.chords();
		let roots = Object.keys(chords);
		for (let root of roots) {
			if (root <= upTo) // TODO: really lower equal? not just lower?
				numofChordedNotes += chords[root].length;
			else
				break; // OrderedDict;
		}
		return numofChordedNotes;
	}

	time_deltas(numOfNotes) {
		const numofChordedNotes = this._numofChordedNotes(numOfNotes);
		const end = numOfNotes + 1 + numofChordedNotes;

		let time_deltas = this._msgs.slice(0, end).map(msg => msg.time_delta);
		if (numOfNotes >= this._msgs.length) {
			// if user specified as much notes as in txt file, add a fake "last note" lasting 1 second
			// this is to prevent cropping of last note
			time_deltas.push(1);
		}
		return time_deltas;
	}
}

module.exports = Messages;

const log = s => [`%c${s}`, 'color: #245ed1'];
let { EStore, Python } = require("pyano_local_modules/ext_libs");
let { round, path_exists, remove_ext, $fadeOut, $fadeInMany, $fadeOutMany, $fadeIn } = require("pyano_local_modules/util");
let { safeSwitchCss, $MainContent, $Sidebar, $Title } = require("pyano_local_modules/document");
let { Alert } = require("pyano_local_modules/util/Alert");
let Path = require("path");
const $ = require('jquery');
const fs = require("fs");

/**@return {Number[]}*/
async function getOnsetTimes(filePath) {
	console.log(...log(`getOnsetTimes(${filePath})`));
	Alert.small.info('Getting onsets...');
	const options = { args: [filePath] };
	let onsets = await Python.runAsync("Record/get_onset_times.py", options);
	console.log(...log('onsets'), onsets);
	return onsets;


}

/**@param {String} filePath
 @param {Number} firstOnset
 @param {Number} silenceLen
 @param {Number?} toSecs
 @param {Number?} notesNum*/
async function trimAndForceSilence(filePath, firstOnset, silenceLen, toSecs, notesNum) {
	console.log(...log(`trimAndForceSilence(filePath, ${firstOnset}, ${silenceLen}, ${toSecs}, ${notesNum})`));
	let options = { args: [filePath, firstOnset, silenceLen] };
	if (toSecs && notesNum)
		options.args.push(toSecs, notesNum);
	const trimmedFilePath = await Python.runAsync("Record/trim_and_force_silence.py", options);
	console.log(...log('trimmedFilePath'), trimmedFilePath);
	return trimmedFilePath[0];


}

async function handleMov(name, path) {
	let { value: shouldConvert } = await Alert.big.blocking({
		title: 'Convert to mp4?',
		html: name,
		showConfirmButton: true,
		showCancelButton: true,
	});
	if (!shouldConvert) {
		Alert.small.info('Not converting.');
		return;
	}

	let { execSync } = require('child_process');
	let mp4 = Path.join(Path.dirname(path), Path.basename(name, '.mov')) + '.mp4';
	try {
		execSync(`ffmpeg -i "${path}" -codec copy "${mp4}"`, { encoding: 'utf8', stdio: 'inherit' });
		Alert.small.success('Converted successfully.');
	} catch (e) {
		Alert.small.error('Convert failed', 'Maybe the converted file exists already?');
	}


}

const MP4 = (() => {
	async function cleanSilence(name, path) {
		let { value: shouldClean } = await Alert.big.blocking({
			title: 'Clean silence from both ends?',
			html: name,
			showConfirmButton: true,
			showCancelButton: true,
		});
		if (!shouldClean) {
			Alert.small.info('Not cleaning.');
			return;
		}

		let trimmedFilePath = `${remove_ext(path)}_trimmed.mp4`;
		let trimmedExists = await path_exists(trimmedFilePath);
		console.log({ trimmedFilePath, trimmedExists });
		if (trimmedExists) {
			let { value: doAnyway } = await Alert.small.warning("A trimmed version of this file already exists. Continue anyway?", `Here: ${trimmedFilePath}`, true);
			console.log({ doAnyway });
			if (doAnyway) {
				await fs.unlinkSync(trimmedFilePath);
			} else {
				Alert.small.info('Not trimming.');
				return;
			}
		}

		const onsets = await getOnsetTimes(path);
		Alert.big.blocking({ title: 'How long was it until you played the first note?' },
			{
				strings: onsets.map(o => round(o, 1)),
				clickFn: async $s => {
					console.log(`user chose ${$s.text()}`);
					await trimAndForceSilence(path, $s.text(), EStore.vidSilenceLen());
					Alert.small.success('Trimmed successfully.');
				}
			});


	}

	return { cleanSilence };
})();

async function handleMp4(name, path) {
	if ('trimmed'.in(name)) {

	} else {
		await MP4.cleanSilence(name, path);
	}

}


async function onDrop(e) {
	let { name, path, size, type } = e.originalEvent.dataTransfer.files[0];
	if (!"video".in(type)) {
		Alert.small.warning('Not a video file');
		return;
	}
	name = name.lower();
	if (name.endsWith('mov'))
		return await handleMov(name, path);
	if (name.endsWith('mp4'))
		return await handleMp4(name, path);
}

const videoToolsPage = {
	switch: async (reload) => {
		console.log(...log(`videoToolsPage.switch(${reload})`));
		EStore.setLastPage('video_tools');
		if (reload) {
			let { remote } = require("electron");
			const currentWindow = remote.getCurrentWindow();
			currentWindow.reload();
		}
		await $fadeOut($MainContent, 100);
		$MainContent.empty();
		require("pyano_local_modules/sidebar").to_video_tools();
		safeSwitchCss("templates/css/video_tools.css");
		let $bigMessage = $('<div id="big_message">')
			.text('Drop a video file');
		let $dropArea = $('<div id="drop_area">')
			.on({
				'dragover dragenter': e => {
					e.preventDefault();
					e.stopPropagation();
				}, 'drop': async e => await onDrop(e)
			});

		$MainContent.append($bigMessage, $dropArea);
		await $fadeIn($MainContent, 300);
	}
};

module.exports = videoToolsPage;

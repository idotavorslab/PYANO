// **pages/InsideTest/Gui.js
const $ = require('jquery');
let {
	$fadeIn,
	$fadeInMany,
	$fadeOut,
	$fadeOutMany,
	Alert,
	bool,
	concurrent,
	float,
	int,
	Messages,
	min,
	num2eng,
	range,
	strong,
	enumerate,
	sum,
	wait,
} = require("pyano_local_modules/util");
let {
	EStore,
	Python
} = require("pyano_local_modules/ext_libs");
const Svg = require("./Svg");
const fs = require("fs");


const log = s => [`%c${s}`, 'color:#9876aa'];
const logsm = (...args) => [`%c${args.join(' ')}`, `font-size:10px`];

class Video {
	/**@param {jQuery} $video*/
	constructor($video) {
		this.$element = $video;
		this.firstOnset = null;
		// this.loaded = false;
	}

	init() {
		let trimmedFilePath = `${EStore.truthFilePath()}.mp4`;
		let vidsrcfile = `file:///${trimmedFilePath}`;
		let src = `<source src="${vidsrcfile}" type="video/mp4">`;
		this.$element.append(src);
		let data = fs.readFileSync(`${EStore.truthFilePath()}_onsets.json`);
		/**@type {{onsets:String[],first_onset_index:Number}}*/
		data = JSON.parse(data);
		console.log('Video.data from onsets.json', { data });
		this.firstOnset = float(data.onsets[data.first_onset_index]);
		this.lastOnset = float(data.onsets.last());

		const events = [
			'canplay',  // not enough data has been loaded to play the media up to its end
			'canplaythrough', // can play the media up to its end
			'emptied',
			'ended', // reached end
			'loadeddata', // first frame of media has finished loading
			'loadedmetadata',
			'play', // Playback has begun
			'playing', // Playback is ready to start after having been paused or delayed due to lack of data.
			'stalled', // trying to fetch media data, but is not coming
			'suspend', // Media data loading has been suspended.
			'waiting', // stopped because of a temporary lack of data
		];
		for (let ev of events) {
			const evFired = `${ev}Fired`;
			this[evFired] = false;
			this.vidElm[`on${ev}`] = () => this[evFired] = true;
		}
		this.vidElm.onmousedown = e => {
			console.log('%cvideo mousedown', 'color:#de7d36', { isTrusted: e.isTrusted });
			this.vidElm.play();
		};

	}

	_promisePlaying() { // on err
		console.log(...logsm('_promisePlaying() started'));
		return new Promise(resolve => {

			return this.vidElm.onplaying = () => {
				console.log(...logsm('_promisePlaying() resolving'));
				resolve();
			};
		});
	}

	_promiseEnded() { // on err
		console.log(...logsm('_promiseEnded() started'));
		return new Promise(resolve => this.vidElm.onended = () => {
			console.log(...logsm('_promiseEnded() resolving'));
			resolve();
		});
	}

	_setCurrentTimeToFirstOnset() {
		console.log(...logsm('_setCurrentTimeToFirstOnset()'));
		this.vidElm.currentTime = this.firstOnset - 0.1;
	}


	_promiseReady() {
		console.log('_promiseReady() started');
		return new Promise(resolve => this.vidElm.onloadeddata = () => {
			console.log('_promiseReady() resolving');
			resolve();
		});
	}


	_promiseFadeIn() {
		console.log(...logsm('_promiseFadeIn()'));
		if (this.vidElm.volume != 0)
			console.warn('_promiseFadeIn volume not 0', this.vidElm.volume);
		return new Promise(resolve => this.$element.animate({ volume: 1 }, 50, resolve));
	}

	_promiseFadeOut() {
		console.log(...logsm('_promiseFadeOut()'));
		if (this.vidElm.volume != 1)
			console.warn('_promiseFadeIn volume not 1', this.vidElm.volume);
		return new Promise(resolve => this.$element.animate({ volume: 0 }, 75, resolve));
	}

	_logEvents() {
		console.group(...logsm('_logEvents()'));
		for (let [evprop, val] of enumerate(this))
			if (evprop.endsWith('Fired')) {
				if (val)
					console.log(evprop.upTo('Fired'), val);
				else
					console.log(...logsm(evprop.upTo('Fired')));
			}
		console.groupEnd();
	}

	/**@return {HTMLMediaElement}*/
	get vidElm() {
		return this.$element[0];
	}


	/**@param {Number?} numOfNotes
	 @return {Promise<void>}*/
	async play(numOfNotes = null) {
		console.group(`Video.play(numOfNotes = `, numOfNotes, ')');
		this._logEvents();
		const { canplaythroughFired, loadeddataFired } = this;
		if (!canplaythroughFired || !loadeddataFired) {
			console.log('\t!canplaythroughFired || !loadeddataFired, calling load()');
			this.vidElm.load();
			await this._promiseReady();
		}
		this._setCurrentTimeToFirstOnset();


		this.vidElm.volume = 0;
		let waitValue;
		let logData = {};
		if (numOfNotes == null) {
			if (this.lastOnset < this.vidElm.duration) {
				let diff = this.vidElm.duration - this.lastOnset;
				diff = min(1.5, diff);
				logData = { ...logData, diff };
				waitValue = 1000 * (this.lastOnset + diff - this.firstOnset);
			} else {
				waitValue = 1000 * (this.vidElm.duration - this.firstOnset);
			}

			logData = {
				...logData,
				'this.firstOnset': this.firstOnset,
				'this.lastOnset': this.lastOnset,
				'this.vidElm.duration': this.vidElm.duration,

			};
		} else {
			const options = { args: [EStore.truthFilePath('txt')], mode: "json" };
			let messages = await Python.runAsync('InsideTest/normalize_txt_file.py', options);
			/**@type {Messages}*/
			messages = new Messages(messages);
			let tdeltas = messages.time_deltas(numOfNotes);

			waitValue = sum(tdeltas) * 1000;
			logData = { ...logData, tdeltas, messages };


		}
		console.log({
			waitValue, 'this.vidElm.currentTime': this.vidElm.currentTime,
			...logData
		});


		try {
			await concurrent(this._promiseFadeIn(), await this.vidElm.play(), wait(waitValue));
			await concurrent(this._promiseFadeOut(), this.vidElm.pause());
			this._setCurrentTimeToFirstOnset();
		} catch (e) {
			console.warn(e);
			if (e.message.startsWith("play() failed because the user didn't interact with the document first.")) {


				this.$element.css('z-index', 2000);
				let { remote } = require("electron");
				const currentWindow = remote.getCurrentWindow();
				console.log('currentWindow.webContents.sendInputEvent', currentWindow.webContents.sendInputEvent({
					type: 'mouseDown',
					x: 1000,
					y: 500,
					button: 'left',
				}));

				await this._promisePlaying();
				await this._promiseEnded();
				this.$element.css('z-index', -1);

			} else {
				Alert.small.error("Can't play", e.message);
				throw e;
			}
		}
		console.groupEnd();
	}

	async pause() {
		return await this.vidElm.pause();
	}
}

class Animation {
	/**@param {jQuery} $animation*/
	constructor($animation) {
		/**@type {jQuery}*/
		this.$element = $animation;
		let svgs = [];
		for (let i of range(0, 51)) {
			if (i == 0) {
				svgs.push(Svg.blackRight);
				continue;
			} else if (i == 51) {
				svgs.push(Svg.base);
				continue;
			}
			let searchElement = i % 7;
			if ([2, 5].includes(searchElement))
				svgs.push(Svg.blackRight);
			else if ([1, 4, 8].includes(searchElement))
				svgs.push(Svg.blackLeft);
			else // [0, 3, 6, 7]
				svgs.push(Svg.blackBoth);
		}
		this.$element.append(svgs);

	}

	/**@param {Number} note*/
	_note2svgIndex(note) {
		let scaleStart = int(note / 12) * 7 - 11;
		let indexInScale = note % 12;
		let index = scaleStart + [0, 0, 1, 1, 2, 3, 3, 4, 4, 5, 5, 6][indexInScale];
		if (![0, 2, 4, 5, 7, 9, 11].includes(indexInScale))
			return [index, index + 1];
		return index;

	}

	/**
	 @param {Number} note
	 @param {Number} noteDuration
	 @param {String} fill
	 * */
	async markKey(note, noteDuration, fill) {
		return new Promise(async resolve => {
			let index = this._note2svgIndex(note);
			let $toMark, baseFill;
			let $children = this.$element.children();
			if (index.length != undefined) { // [3,4] for example
				let [indexLeft, indexRight] = index;
				let $keyLeft = $children.filter(`svg:nth-child(${indexRight})`).children(`.piano-black-left-rect`);
				let $keyRight = $children.filter(`svg:nth-child(${indexLeft})`).children(`.piano-black-right-rect`);
				$toMark = $keyLeft.add($keyRight);
				baseFill = 'black';
			} else { // 3
				$toMark = $children.filter(`svg:nth-child(${index})`).children(`.piano-white-rect`);
				baseFill = 'white';
			}
			$toMark.css({
				fill
			});
			await wait(noteDuration);
			$toMark.css({
				fill: baseFill
			});
			resolve();


		});

	}


}

async function _setup({ includeSecondary = true, fadeInBigMsg = true }) {
	if (fadeInBigMsg)
		await $fadeIn($bigMessage, 700);
	await $fadeIn($smallMessage, 700);
	if (includeSecondary) {
		await wait(700);
		await $fadeIn($smallMessageSecondary, 700);
	}
	await wait(1500);
	if (includeSecondary)
		await $fadeOutMany(1500, $smallMessage, $bigMessage, $smallMessageSecondary);
	else
		await $fadeOutMany(1500, $smallMessage, $bigMessage);

}

async function _presetup() {
	await concurrent(
		$fadeIn($bigMessage, 700),
		$fadeOutMany(200, $smallMessage, $bigButton)
	);
	await wait(700);
}

async function _runVideo(numOfNotes = null) {
	const { $Sidebar, $Title, } = require("pyano_local_modules/document");
	await concurrent(
		$fadeIn(video.$element, 700),
		// $fadeOutMany(700, $Sidebar, $Title, $pageSubtitle)
	);
	await video.play(numOfNotes);
	await wait(1500);
	await concurrent(
		$fadeOut(video.$element, 700),
		// $fadeInMany(700, $Sidebar, $Title, $pageSubtitle)
	);
	// await $fadeOut(video.$element, 700);
}

async function _runAnimation(midi, playOptions) {
	await $fadeIn(animation.$element, 700);
	await midi.playMidiFile(playOptions);
	await wait(1500);
	await $fadeOut(animation.$element, 700);
}

/**@param {Midi} midi
 @param {Piano|Tone.AudioNode} playbackPiano*/
async function playWholeTruthDemo(midi, playbackPiano) {
	console.log(...log('Gui.playWholeTruthDemo()'));
	$bigMessage.text(`A tutorial`);
	let smallMessage = `Here's a demo that shows you what you will be playing.`;
	$smallMessage.html(smallMessage);

	await _setup({ includeSecondary: false });
	/*await $fadeIn($bigMessage, 700);
	await $fadeIn($smallMessage, 700);
	await wait(1500);
	await $fadeOutMany(1500, $smallMessage, $bigMessage);
	*/

	if (EStore.isDemoVideo()) {
		await _runVideo();
		/*await $fadeIn(video.$element, 700);
		await video.play();
		await wait(1500);
		await $fadeOut(video.$element, 700);
		*/
	} else {
		let playOptions = {
			midiFilePath: EStore.truthFilePath('mid'),
			animation,
			playbackPiano
		};
		await _runAnimation(midi, playOptions);
		/*await $fadeIn(animation.$element, 700);
		await midi.playMidiFile(playOptions);
		await wait(1500);
		await $fadeOut(animation.$element, 700);
		*/
	}

}


/**@param {Midi} midi
 @param {Piano} playbackPiano
 @param {Number} levelIndex
 @param {Number} trialIndex
 @param {Number} numOfNotes
 @return {Promise<void>}*/
async function playPreTrialDemo(midi, playbackPiano, levelIndex, trialIndex, numOfNotes) {
	console.log(...log('Gui.playPreTrialDemo()'));
	const trialNumEnglish = num2eng(trialIndex + 1, true);
	if (trialIndex == 0)
		$bigMessage.text(`${num2eng(levelIndex + 1, true).title()} level, ${trialNumEnglish} trial.`);
	else
		$bigMessage.text(`Let's move on to the ${trialNumEnglish} trial.`);
	$smallMessage.html(`You are going to play <b>${numOfNotes}</b> notes.`);
	$smallMessageSecondary.html(`Here's a demo showing only these <b>${numOfNotes}</b> notes.`);

	await _setup({ includeSecondary: true });
	/*await $fadeIn($bigMessage, 700);
	await $fadeIn($smallMessage, 700);
	await wait(700);
	await $fadeIn($smallMessageSecondary, 700);
	await wait(1500);
	await $fadeOutMany(1500, $bigMessage, $smallMessage, $smallMessageSecondary);
	*/

	if (EStore.isDemoVideo() && trialIndex == 0) {
		await _runVideo(numOfNotes);
		/*await $fadeIn(video.$element, 700);
		await video.play(numOfNotes);
		await wait(1500);
		await $fadeOut(video.$element, 700);
		*/
	}

	let playOptions = {
		midiFilePath: EStore.truthFilePath('mid'),
		animation,
		numOfNotes,
		playbackPiano
	};
	await _runAnimation(midi, playOptions);
	/*await $fadeIn(animation.$element, 700);
	await midi.playMidiFile(playOptions);
	await wait(1500);
	await $fadeOut(animation.$element, 700);
	*/


	$smallMessage.html(`Please play <b>${numOfNotes}</b> notes.`);
	await $fadeInMany(300, $bigButton, $smallMessage);

}


/**@param {Midi} midi
 @param {Piano} playbackPiano
 @param {Number} trialIndex
 @param {String[]} mistakes
 @return {Promise<void>}*/
async function showFailedTrialFeedback(midi, playbackPiano, trialIndex, mistakes) {
	console.log(...log('Gui.showFailedTrialFeedback()'));
	$bigMessage.text("Oi vei!");
	await _presetup();
	/*await concurrent(
		$fadeIn($bigMessage, 700),
		$fadeOutMany(200, $smallMessage, $bigButton)
	);
	await wait(700);
	*/
	const badAccuracyInTempo = bool(mistakes) &&
	                           'note'.in(mistakes) &&
	                           EStore.isLearningTempo();
	if (badAccuracyInTempo) {
		$smallMessage.text(`You got some notes wrong.`);
		$smallMessageSecondary.text("Please try this trial again.");
	} else {
		$smallMessage.text(`You almost got the ${num2eng(trialIndex + 1)} trial right.`);
		$smallMessageSecondary.text("Here's an animation showing the errors.");
	}
	await _setup({ fadeInBigMsg: false });
	/*await $fadeIn($smallMessage, 700);
	await wait(700);
	await $fadeIn($smallMessageSecondary, 700);
	await wait(1500);
	await $fadeOutMany(1500, $bigMessage, $smallMessage, $smallMessageSecondary);
	*/


	const numOfNotes = mistakes.length;

	let playOptions = {
		midiFilePath: EStore.truthFilePath('mid'),
		animation,
		numOfNotes,
		mistakes,
		playbackPiano,
	};
	playOptions.speed = EStore.isLearningTempo() ? 1
	                                             : EStore.currentTest().errors_playingspeed;
	await _runAnimation(midi, playOptions);
	/*await $fadeIn(animation.$element, 700);
	await midi.playMidiFile(playOptions);
	await wait(1500);
	await $fadeOut(animation.$element, 700);
	*/
}

/**@param {Midi} midi
 @param {Piano} playbackPiano
 @param {Number} trialIndex*/
async function showPassedTrialFeedback(midi, playbackPiano, trialIndex) {
	console.log(...log('Gui.showPassedTrialFeedback()'));
	$bigMessage.text(`Good job! You passed the ${num2eng(trialIndex + 1)} trial.`);
	await _presetup();
	/*await concurrent(
		$fadeIn($bigMessage, 700),
		$fadeOutMany(200, $smallMessage, $bigButton)
	);
	await wait(700);
	*/
	const numOfNotes = EStore.numOfNotesCurrLevel();
	$smallMessage.html(`Let's show you those same <b>${numOfNotes}</b> notes you just got correctly.`);
	$smallMessageSecondary.html(`This will make you even better.`);

	await _setup({ fadeInBigMsg: false });
	/*await $fadeIn($smallMessage, 700);
	await wait(700);
	await $fadeIn($smallMessageSecondary, 700);
	await wait(1500);
	await $fadeOutMany(1000, $bigMessage, $smallMessage, $smallMessageSecondary);
	*/

	await _runAnimation(midi, {
		midiFilePath: EStore.truthFilePath('mid'),
		animation,
		numOfNotes,
		playbackPiano
	});
	/*await $fadeIn(animation.$element, 700);
	await midi.playMidiFile({
		midiFilePath: EStore.truthFilePath('mid'),
		animation,
		numOfNotes,
		playbackPiano
	});
	await wait(1500);
	await $fadeOut(animation.$element, 700);
	*/
}

async function showTestCompleteMessages() {
	console.log(...log('Gui.showTestCompleteMessages()'));
	$bigMessage.text(`Test is over!`);
	$smallMessage.html('You deserve an ice cream. ðŸ¦');

	await $fadeInMany(700, $bigMessage, $smallMessage);
}


/**@param {TLevel[]} levels
 @return {Number[]}*/
function updateLevelTrialSubtitles(levels) {
	let [levelIndex, trialIndex] = EStore.currentTrialCoords();
	$('#page_subtitle > div:nth-child(1) > strong')
		.text(EStore.truthFileName({
			withExtension: false
		}));
	$('#page_subtitle > div:nth-child(2) > strong')
		.text(`${levelIndex + 1}/${levels.length}`);
	$('#page_subtitle > div:nth-child(3) > strong')
		.text(`${trialIndex + 1}/${levels[levelIndex].trials}`);

	return [levelIndex, trialIndex];
}

let $pageSubtitle = $('<div class="subtitle" id="page_subtitle">')
	.append(
		`<div>Truth file: ${strong(EStore.truthFileName({ withExtension: false }))}</div>`,
		`<div>Level: <strong>1/1</strong></div>`,
		`<div>Trial: <strong>1/1</strong></div>`,
	);
let $bigMessage = $('<div id="big_message">').hide();
let $smallMessage = $('<div class="subtitle" id="small_message">').hide();
let $smallMessageSecondary = $('<div class="subtitle" id="small_message_secondary">')
	.hide();
let $bigButton = $('<button id="big_button">')
	.addClass("my-btn active-btn")
	.append("<span>I'm done playing</span>")
	.hide();
let animation = new Animation($('<div id="animation">').hide());

let video = new Video($(`<video width="1750" preload="auto" id="video">`).hide());


module.exports = {
	$pageSubtitle,
	$bigMessage,
	$smallMessageSecondary,
	$smallMessage,
	$bigButton,
	playPreTrialDemo,
	showPassedTrialFeedback,
	showFailedTrialFeedback,
	showTestCompleteMessages,
	playWholeTruthDemo,
	updateLevelTrialSubtitles,
	animation,
	video
};

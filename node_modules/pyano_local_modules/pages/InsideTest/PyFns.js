let { Python, EStore } = require("pyano_local_modules/ext_libs");
const log = s => [`PyFns.%c${s}`, 'color:#698651'];

/**@param {Truth} truth
 * @param {Truth} trialTruth
 * @return {Promise<{ passed: boolean, mistakes: string[] }>}*/
function checkDoneTrial(truth, trialTruth) {
	console.log(...log('checkDoneTrial()'));
	return new Promise((resolve, reject) => {

		// const full_truth_file_path = EStore.truthFilePath('txt');
		// const trial_file_path = EStore.trialFilePath('txt');
		const { learning_type, allowed_tempo_deviation_factor } = EStore.currentTest();
		let num_of_notes_to_test;
		if (learning_type == 'tempo')
			num_of_notes_to_test = truth.numOfNotes();
		else
			num_of_notes_to_test = EStore.numOfNotesCurrLevel();
		const data = {
			learning_type,
			allowed_tempo_deviation_factor,
			trial_file_path: trialTruth.txt.on.path,
			full_truth_file_path: truth.txt.on.path,
			num_of_notes_to_test
		};
		console.log(...log('\tcheckDoneTrial, sending data'), data);
		Python.run('InsideTest/check_done_trial.py', {
				args: [JSON.stringify(data)],
				mode: "json"
			},
			async (err, output) => {
				if (err) {
					reject(err);
				}
				let { passed, mistakes } = output[0];
				console.log(...log('\tcheckDoneTrial resolving'), { passed, mistakes });
				resolve({ passed, mistakes });

			});


	});
}

/**@param {Truth} truth
 @return {Promise<{on_msgs:TMessage[], off_msgs:TMessage[], on_off_pairs:TOnOffPairs, all_msgs:TMessage[]}>}*/
async function merge_on_off_txt_files(truth) {
	let msgs = await Python.runAsync('InsideTest/merge_on_off_txt_files.py', {
		args: [truth.txt.base.path, truth.txt.on.path, truth.txt.off.path],
		mode: "json"
	});
	let { all_msgs, on_msgs, off_msgs, on_off_pairs } = msgs[0];
	debugger;
	return { all_msgs, on_msgs, off_msgs, on_off_pairs };
}

module.exports = {
	checkDoneTrial,
	merge_on_off_txt_files
};

let { safeSwitchCss, $MainContent, $Title, $Sidebar } = require("pyano_local_modules/document");
let { EStore, Python } = require("pyano_local_modules/ext_libs");
let PyFns = require("./PyFns");
const Pages = () => require("pyano_local_modules/pages/pages");

let { $pageSubtitle, $bigMessage, $smallMessage, $smallMessageSecondary, $bigButton, animation, video } = require("./Gui");
const Gui = require("./Gui");
let { Midi, toMidiFromMessages } = require("pyano_local_modules/gilad");
let Piano = require("pyano_local_modules/gilad/Piano");
const fs = require("fs");
const log = (s, { b, sm } = {}) => [`%cinsidetest.${s}`,
                                    `color: #58a4c8; ${b ? 'font-weight:900;' : ''} ${sm ? 'font-size:10px;' : ''}`];

/**@param {Midi} userMidi
 @param {Piano} animationPiano
 @param {Truth} truth
 @return {Promise<Truth>}*/
async function _runTrial(userMidi, animationPiano, truth) {
	console.log(...log('_runTrial()'));
	let { levels, finished_trials_count } = EStore.currentTest();
	Gui.updateLevelTrialSubtitles(levels, truth);

	let [levelIndex, trialIndex] = EStore.currentTrialCoords();

	let numOfNotes = levels[levelIndex].notes;
	/*if (EStore.isLearningTempo()) {
		numOfNotes = truth.numOfNotes();
	} else {
		numOfNotes = levels[levelIndex].notes;
	}
	*/

	// No pre trial demo if just started in tempo mode. Demo already played everything the user needs
	const withPreTrialDemo = finished_trials_count != 0;
	if (withPreTrialDemo)
		await Gui.playPreTrialDemo({ animationPiano, levelIndex, trialIndex, numOfNotes, truth });
	await Gui.$smallMessageAndGuiIn(numOfNotes);
	const trialTruth = EStore.trialTruth();

	return await userMidi.newOnOffTxtWriteStreams(trialTruth);

}


/**@param {Midi} userMidi
 @param {Piano} animationPiano
 @param {Truth} truth
 @param {Truth} trialTruth
 @return {Promise<boolean>}*/
async function _handleDoneTrial(userMidi, animationPiano, truth, trialTruth) {
	console.log(...log('_handleDoneTrial(userMidi, animationPiano, trialTruth)'));

	await Python.runAsync('InsideTest/normalize_txt_file.py', { args: [trialTruth.txt.on.path], mode: "json" });
	// let msgs = await Python.runAsync('InsideTest/merge_on_off_txt_files.py', {
	// 	args: [trialTruth.txt.base.path, trialTruth.txt.on.path, trialTruth.txt.off.path],
	// 	mode: "json"
	// });
	// let { on_off_pairs } = msgs[0];
	let { on_off_pairs } = await PyFns.merge_on_off_txt_files(trialTruth);
	await userMidi.endOnOffTxtStreamsAndWriteMidi(on_off_pairs, trialTruth);
	let { passed, mistakes } = await PyFns.checkDoneTrial(truth, trialTruth);

	let [_, trialIndex] = EStore.currentTrialCoords();
	const badAccuracyWhenCheckingRhythm = bool(mistakes)
	                                      && 'note'.in(mistakes)
	                                      && EStore.isCheckingRhythmInLevel();
	console.log(...log(`\tbadAccuracyWhenCheckingRhythm: `), badAccuracyWhenCheckingRhythm);
	if (passed) {
		await Gui.showPassedTrialFeedback(animationPiano, trialIndex, truth);
	} else { // did not pass

		await Gui.showFailedTrialFeedback({ animationPiano, trialIndex, mistakes, truth });
	}

	if (!badAccuracyWhenCheckingRhythm) {
		// don't increase if got wrong acc in tempo mode
		EStore.increase("current_test.finished_trials_count");
	} else {
		let failIndex = 0;
		console.log(`Trying to rename ${trialTruth.pathNoExt} with failIndex: ${failIndex}`);
		let newPath = `${trialTruth.pathNoExt}_ACCFAIL_${failIndex}`;
		let newPathExists = await fsx.path_exists(`${newPath}.txt`);
		while (newPathExists) {

			failIndex += 1;
			console.log(`\tFile exists, trying failIndex: ${failIndex}`);
			newPath = `${trialTruth.pathNoExt}_ACCFAIL_${failIndex}`;
			newPathExists = await fsx.path_exists(`${newPath}.txt`);
		}
		console.log(`\trenaming to: ${newPath}`);
		const newTruth = new Truth(newPath);
		await trialTruth.txt.renameByOtherTxt(newTruth.txt);
		/*await asx.concurrent(
			trialTruth.txt.renameByOtherFile(newTruth.txt),
			trialTruth.midi.renameByOtherFile(newTruth.midi));
		*/
		/* fs.renameSync(trialTruth.txt.base.path, newTruth.txt.base.path);
		 fs.renameSync(trialTruth.txt.on.path, newTruth.txt.on.path);
		 fs.renameSync(trialTruth.txt.off.path, newTruth.txt.off.path);
		 fs.renameSync(trialTruth.midi.path, newTruth.midi.path);
		*/
	}
}

async function _maybeCreateOutputDir() {
	console.log(...log('_maybeCreateOutputDir()', { sm: true }));
	const outputDir = EStore.testOutPath();
	let exists = await fsx.path_exists(outputDir);

	if (!exists)
		await fsx.mkdir(outputDir + '/', { recursive: true });

	else
		fs.stat(outputDir, async (err, stats) => {

			let datestr = stats.ctime.human();
			await fs.renameSync(outputDir, `${outputDir}_${datestr}`);
			await fsx.mkdir(outputDir + '/', { recursive: true });


		});


}

/**@param {Midi} userMidi
 @param {Truth} truth*/
async function _maybeWriteMidiFileFromTxt(userMidi, truth) {
	console.log(...log('_maybeWriteMidiFileFromTxt(userMidi, truth)', { sm: true }));
	if (await !truth.txt.allExist())
		return Promise.reject(`_maybeWriteMidiFileFromTxt, not all txt files exist for truth: "${truth.name}"`);


	if (await truth.midi.exists()) // good
		return;


	await Python.runAsync('InsideTest/normalize_txt_file.py', { args: [truth.txt.on.path], mode: "json" });
	let msgs = await Python.runAsync('InsideTest/merge_on_off_txt_files.py', {
		args: [truth.txt.base.path, truth.txt.on.path, truth.txt.off.path],
		mode: "json"
	})[0];
	let { on_off_pairs } = msgs[0];
	await toMidiFromMessages(on_off_pairs, truth);
}

async function _maybeAlertBadConfig() {
	console.log(...log('_maybeAlertBadConfig()', { sm: true }));
	if (EStore.currentTest().levels // if has zeroes
	          .some(pair => !bool(int(pair.notes)) || !bool(int(pair.trials)))) {
		await Alert.big.blocking({
			title: `I found at least one level with "zero" notes or trials`,
			html: 'You will be redirected to New Test page',
			showCancelButton: false,
		});
		return Pages().newTestPage.switch(true);
	}
}

/**@param {Truth} truth*/
async function _maybeAlertNoVideo(truth) {
	console.log(...log('_maybeAlertNoVideo(truth)', { sm: true }));
	if (!EStore.isDemoVideo())
		return;
	if (await truth.mp4.exists())
		return; // good
	let movexists = await truth.mov.exists();
	let html = movexists
	           ? `Looks like a .mov file exists though. Go to File Tools?`
	           : `A .mov file doesn't exist either. Switch to Animation mode?`;
	let { value } = await Alert.big.warning({
		title: `Can't find a video file: ${truth.mp4.name}`,
		html,
		showCancelButton: false
	});

	if (value) {
		if (movexists) {
			return Pages().fileToolsPage.switch(true);
		} else {
			EStore.setDemoType('animation');
			return reloadPage();
		}
	}

}

/**@param {Truth} truth*/
async function _maybeCreateOnsetsJson(truth) {
	console.log(...log('_maybeCreateOnsetsJson(truth)', { sm: true }));
	if (!EStore.isDemoVideo())
		return;

	if (!(await truth.onsets.exists())) {
		await Alert.big.blocking({
			title: `Can't find onsets file: ${truth.onsets.name}`,
			html: 'You will be redirected to File Tools page',
			showCancelButton: false,
		});
		return Pages().fileToolsPage.switch(true);

	} else {
		let data = JSON.parse(await fs.readFileSync(truth.onsets.path));
		if (("onsets" in data) && ("first_onset_index" in data))
			return; // good

		console.log('\tonsets file doesnt have both "onsets" and "first_onset_index" keys');
		await Alert.big.blocking({
			title: `Onsets file seems currupt: ${truth.onsets.name}`,
			html: 'You will be redirected to File Tools page',
			showCancelButton: false
		});
		return Pages().fileToolsPage.switch(true);


	}


}

const insideTestPage = {
	switch: async reload => {
		console.group(`insideTestPage.switch(${reload})`);
		await asx.$fadeOutMany(100, $MainContent, $Sidebar, $Title);

		EStore.set({ last_page: 'inside_test', dev: false, 'current_test.finished_trials_count': 0 });
		if (reload)
			return reloadPage();

		Alert.small._info({
			title: 'Checking for missing files...',
			timer: 1000,
			onAfterClose: () => Alert.small._success({ title: 'All good', timer: 1500 })
		});

		let current_test = EStore.currentTest();
		let { finished_trials_count, levels } = current_test;
		// User plays it, does all the txt/mid writing
		let userMidi = new Midi({ name: 'insidetest.userMidi', muteUserPiano: true });
		// Passively plays the midi animation
		/**@type {Piano}*/
		let animationPiano = new Piano(`file:///${EStore.salamanderDirPath()}`, 'insidetest.animationPiano', [21, 108], 5).toMaster();
		animationPiano.load();
		const truth = EStore.truth();
		await asx.concurrent(
			_maybeCreateOutputDir(),
			_maybeWriteMidiFileFromTxt(userMidi, truth),
			_maybeAlertBadConfig(),
			_maybeAlertNoVideo(truth),);

		// Video file exists for sure because of _maybeAlertNoVideo
		await _maybeCreateOnsetsJson(truth);
		$MainContent.empty();
		require("pyano_local_modules/sidebar").to_inside_test();
		safeSwitchCss("templates/css/inside_test.css");
		if (EStore.isDemoVideo())
			await video.init(truth);
		$MainContent.append(
			$pageSubtitle,
			$bigMessage,
			$smallMessage,
			$smallMessageSecondary,
			$bigButton,
			animation.$element,
			video.$element);

		$Title.text(`testing ${current_test.current_subject}`.title());
		Gui.updateLevelTrialSubtitles(levels, truth);
		await asx.$fadeIn($MainContent, 300);
		console.groupEnd();

		if (finished_trials_count == 0)
			await Gui.playWholeTruthDemo(animationPiano, truth, EStore.maxNotesAmongLevels());

		let trialTruth = await _runTrial(userMidi, animationPiano, truth);

		Gui.$bigButton
		   .click(async () => {
			   console.log(...log('$bigButton clicked', true));
			   if ((await trialTruth.txt.on.size()) == 0 || (await trialTruth.txt.off.size()) == 0)
				   return Alert.small.warning('Please play something');

			   await _handleDoneTrial(userMidi, animationPiano, truth, trialTruth);

			   if (!EStore.isWholeTestOver()) {
				   console.log(...log('Test aint over!'));
				   trialTruth = await _runTrial(userMidi, animationPiano, truth);
				   // No more logic - user should click $bigButton

			   } else {
				   animationPiano.dispose();
				   await Gui.showTestCompleteMessages();
			   }
		   });


	}
};
module.exports = insideTestPage;

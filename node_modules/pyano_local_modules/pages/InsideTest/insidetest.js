// **pages/InsideTest/index.js
let { safeSwitchCss, $MainContent, $Title } = require("pyano_local_modules/document");
let { EStore, Python } = require("pyano_local_modules/ext_libs");
let PyFns = require("./PyFns");
const Pages = () => require("pyano_local_modules/pages/pages");
let {
	$fadeIn, $fadeOutMany,
	date2datetime, mkdir,
} = require('pyano_local_modules/util');
let { $pageSubtitle, $bigMessage, $smallMessage, $smallMessageSecondary, $bigButton, animation, video } = require("./Gui");
const Gui = require("./Gui");
let { Midi, toMidiFromMessages } = require("pyano_local_modules/gilad");
let Piano = require("pyano_local_modules/gilad/Piano");
const fs = require("fs");
const { $Sidebar } = require("pyano_local_modules/document");
const log = (s, b = false) => [`insidetest.%c${s}`, `color: #58a4c8${b ? ';font-weight:900' : ''}`];

/**@param {Midi} midi
 @param {Piano} playbackPiano
 @param {Truth} truth
 @return {Promise<Truth>}*/
async function _runTrial(midi, playbackPiano, truth) {
	console.log(...log('_runTrial()'));
	let { levels, finished_trials_count } = EStore.currentTest();
	Gui.updateLevelTrialSubtitles(levels, truth);

	let [levelIndex, trialIndex] = EStore.currentTrialCoords();

	let numOfNotes = levels[levelIndex].notes;
	/*if (EStore.isLearningTempo()) {
		numOfNotes = truth.numOfNotes();
	} else {
		numOfNotes = levels[levelIndex].notes;
	}
	*/

	// No pre trial demo if just started in tempo mode. Demo already played everything the user needs
	const withPreTrialDemo = !(finished_trials_count == 0 && EStore.isLearningTempo());
	if (withPreTrialDemo)
		await Gui.playPreTrialDemo({ midi, playbackPiano, levelIndex, trialIndex, numOfNotes, truth });
	await Gui.$smallMessageAndGuiIn(numOfNotes);
	const trialTruth = EStore.trialTruth();

	return await midi.newOnOffTxtWriteStreams(trialTruth);

}


/**@param {Midi} midi
 @param {Piano} playbackPiano
 @param {Truth} truth
 @param {Truth} trialTruth
 @return {Promise<Boolean>}*/
async function _handleDoneTrial(midi, playbackPiano, truth, trialTruth) {
	console.log(...log('_handleDoneTrial(midi, playbackPiano, trialTruth)'));

	await Python.runAsync('InsideTest/normalize_txt_file.py', { args: [trialTruth.txt.on.path], mode: "json" });
	let msgs = await Python.runAsync('InsideTest/merge_on_off_txt_files.py', {
		args: [trialTruth.txt.base.path, trialTruth.txt.on.path, trialTruth.txt.off.path],
		mode: "json"
	});
	let { on_off_pairs } = msgs[0];
	await midi.endOnOffTxtStreamsAndWriteMidi(on_off_pairs, trialTruth);
	let { passed, mistakes } = await PyFns.checkDoneTrial(truth, trialTruth);

	const badAccuracyInTempo = bool(mistakes)
	                           && 'note'.in(mistakes)
	                           && EStore.isLearningTempo();
	console.log(...log(`\tbadAccuracyInTempo: `), badAccuracyInTempo);
	let trialIndex = EStore.currentTrialCoords()[1];
	if (passed) {
		await Gui.showPassedTrialFeedback(midi, playbackPiano, trialIndex, truth);
	} else { // did not pass

		await Gui.showFailedTrialFeedback({ midi, playbackPiano, trialIndex, mistakes, truth });
	}

	if (!badAccuracyInTempo) {
		// don't increase if got wrong acc in tempo mode
		EStore.increase("current_test.finished_trials_count");
	} else {
		let failIndex = 0;
		console.log(`Trying to rename ${trialTruth.pathNoExt} with failIndex: ${failIndex}`);
		let newPath = `${trialTruth.pathNoExt}_ACCFAIL_${failIndex}`;
		let newPathExists = await fsx.path_exists(`${newPath}.txt`);
		while (newPathExists) {

			failIndex += 1;
			console.log(`\tFile exists, trying failIndex: ${failIndex}`);
			newPath = `${trialTruth.pathNoExt}_ACCFAIL_${failIndex}`;
			newPathExists = await fsx.path_exists(`${newPath}.txt`);
		}
		console.log(`\trenaming to: ${newPath}`);
		const newTruth = new Truth(newPath);
		fs.renameSync(trialTruth.txt.base.path, newTruth.txt.base.path);
		fs.renameSync(trialTruth.txt.on.path, newTruth.txt.on.path);
		fs.renameSync(trialTruth.txt.off.path, newTruth.txt.off.path);
		fs.renameSync(trialTruth.midi.path, newTruth.midi.path);
	}
}

async function _maybeCreateOutputDir() {
	console.log(...log('_maybeCreateOutputDir()'));
	const outputDir = EStore.testOutPath();
	let exists = await fsx.path_exists(outputDir);
	if (!exists)
		await mkdir(outputDir + '/', { recursive: true });

	else
		fs.stat(outputDir, async (err, stats) => {

			let datestr = date2datetime(stats.birthtime);
			await fs.renameSync(outputDir, `${outputDir}_${datestr}`);
			await mkdir(outputDir + '/', { recursive: true });


		});


}

/**@param {Midi} midi
 @param {Truth} truth*/
async function _maybeWriteMidiFileFromTxt(midi, truth) {
	console.log(...log('_maybeWriteMidiFileFromTxt(midi, truth)'));
	if (await !truth.txt.allExist())
		return Promise.reject(`_maybeWriteMidiFileFromTxt, not all txt files exist for truth: "${truth.name}"`);


	if (await truth.midi.exists()) // good
		return;


	await PyFns.normalizeTxtFile(truth);
	let msgs = await Python.runAsync('InsideTest/merge_on_off_txt_files.py', {
		args: [truth.txt.base.path, truth.txt.on.path, truth.txt.off.path],
		mode: "json"
	})[0];
	let { on_off_pairs } = msgs[0];
	await toMidiFromMessages(on_off_pairs, truth);
}

/**@param {Truth} truth*/
async function _maybeAlertNoVideo(truth) {
	console.log(...log('_maybeAlertNoVideo(truth)'));
	if (!EStore.isDemoVideo())
		return;
	if (await truth.mp4.exists())
		return; // good
	let movexists = await truth.mov.exists();
	let html = movexists
	           ? `Looks like a .mov file exists though. Go to File Tools?`
	           : `A .mov file doesn't exist either. Switch to Animation mode?`;
	let { value } = await Alert.big.warning({
		title: `Can't find a video file: ${truth.mp4.name}`,
		html,
		showCancelButton: false
	});

	if (value) {
		if (movexists) {
			return Pages().fileToolsPage.switch(true);
		} else {
			EStore.setDemoType('animation');
			return reloadPage();
		}
	}

}

/**@param {Truth} truth*/
async function _maybeCreateOnsetsJson(truth) {
	console.log(...log('_maybeCreateOnsetsJson(truth)'));
	if (EStore.isLearningTempo() || !EStore.isDemoVideo())
		return;

	if (!(await truth.onsets.exists())) {
		await Alert.big.blocking({
			title: `Can't find onsets file: ${truth.onsets.name}`,
			html: 'You will be redirected to File Tools page',
			showCancelButton: false,
		});
		return Pages().fileToolsPage.switch(true);

	} else {
		let data = JSON.parse(await fs.readFileSync(truth.onsets.path));
		if (("onsets" in data) && ("first_onset_index" in data))
			return; // good

		console.log('\tonsets file doesnt have both "onsets" and "first_onset_index" keys');
		await Alert.big.blocking({
			title: `Onsets file seems currupt: ${truth.onsets.name}`,
			html: 'You will be redirected to File Tools page',
			showCancelButton: false
		});
		return Pages().fileToolsPage.switch(true);


	}


}

const insideTestPage = {
	switch: async reload => {
		console.log(...log(`insideTestPage.switch(${reload})`));
		await $fadeOutMany(100, $MainContent, $Sidebar, $Title);

		EStore.set({ last_page: 'inside_test', dev: false, 'current_test.finished_trials_count': 0 });
		if (reload)
			return reloadPage();

		Alert.small._info({
			title: 'Checking for missing files...',
			timer: 1000,
			onAfterClose: () => Alert.small._success({ title: 'All good', timer: 1500 })
		});

		let current_test = EStore.currentTest();
		let { finished_trials_count, levels } = current_test;
		// user plays it, does all the txt/mid writing, its "playMidiFile" fn is passed playbackPiano
		let midi = new Midi({ name: 'insidetest.midi', muteUserPiano: true });
		// passed to midi "playMidiFile" fn and passively plays the midi animation
		let playbackPiano = new Piano(`file:///${EStore.salamanderDirPath()}`, 'insidetest.playbackPiano', [21, 108], 5).toMaster();
		playbackPiano.load();
		const truth = EStore.truth();
		await asx.concurrent(
			_maybeCreateOutputDir(),
			_maybeWriteMidiFileFromTxt(midi, truth),
			_maybeAlertNoVideo(truth),);

		// Video file exists for sure because of _maybeAlertNoVideo
		await _maybeCreateOnsetsJson(truth);
		$MainContent.empty();
		require("pyano_local_modules/sidebar").to_inside_test();
		safeSwitchCss("templates/css/inside_test.css");
		if (EStore.isDemoVideo())
			await video.init(truth);
		$MainContent.append(
			$pageSubtitle,
			$bigMessage,
			$smallMessage,
			$smallMessageSecondary,
			$bigButton,
			animation.$element,
			video.$element);

		$Title.text(`testing ${current_test.current_subject}`.title());
		Gui.updateLevelTrialSubtitles(levels, truth);
		await $fadeIn($MainContent, 300);


		if (finished_trials_count == 0)
			await Gui.playWholeTruthDemo(midi, playbackPiano, truth, EStore.maxNotesOfLevels());

		let trialTruth = await _runTrial(midi, playbackPiano, truth);

		Gui.$bigButton
		   .click(async () => {
			   console.log(...log('$bigButton clicked', true));
			   let { size: onSize } = await fs.lstatSync(trialTruth.txt.on.path);
			   let { size: offSize } = await fs.lstatSync(trialTruth.txt.off.path);
			   if (onSize == 0 || offSize == 0)
				   return Alert.small.warning('Please play something');

			   await _handleDoneTrial(midi, playbackPiano, truth, trialTruth);

			   if (!EStore.isWholeTestOver()) {
				   console.log(...log('Test aint over!'));
				   trialTruth = await _runTrial(midi, playbackPiano, truth);
				   // No more logic - user should click $bigButton

			   } else {
				   playbackPiano.dispose();
				   await Gui.showTestCompleteMessages();
			   }
		   });


	}
};
module.exports = insideTestPage;

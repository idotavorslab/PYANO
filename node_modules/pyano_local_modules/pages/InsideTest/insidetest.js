let { safeSwitchCss, $MainContent, $Title, $Sidebar } = require("pyano_local_modules/document");
let { EStore, Python } = require("pyano_local_modules/ext_libs");
let PyFns = require("./PyFns");
const Pages = () => require("pyano_local_modules/pages/pages");

let { $pageSubtitle, $bigMessage, $smallMessage, $smallMessageSecondary, $bigButton, animation, video } = require("./Gui");
const Gui = require("./Gui");
const Gilad = require("pyano_local_modules/gilad");
// let { Midi, toMidiFromMessages } = require("pyano_local_modules/gilad");
let Piano = require("pyano_local_modules/gilad/Piano");
const fs = require("fs");
const log = (s, { b, sm } = {}) => [`%cinsidetest.${s}`,
                                    `color: #007acc; ${b ? 'font-weight:900;' : ''} ${sm ? 'font-size:10px;' : ''}`];

/**@param {Midi} userMidi
 @param {Piano} animationPiano
 @param {Truth} truth
 @param {boolean} playPreTrialDemo
 @return {Promise<Truth>}*/
async function _runTrial({ userMidi, animationPiano, truth, playPreTrialDemo = true }) {
	console.log(...log(`_runTrial(userMidi, animationPiano, truth, playPreTrialDemo = ${playPreTrialDemo})`));
	const levels = EStore.getLevels();
	Gui.updateLevelTrialSubtitles(levels, truth);
	if (playPreTrialDemo)
		await Gui.playPreTrialDemo({ animationPiano, levels, truth });
	await Gui.$smallMessageAndGuiIn(levels.current);
	const trialTruth = EStore.trialTruth();

	return await userMidi.newOnOffTxtWriteStreams(trialTruth);

}


/**@param {Midi} userMidi
 @param {Piano} animationPiano
 @param {Truth} truth
 @param {Truth} trialTruth
 @return {Promise<TDoneTrialResult>}*/
async function _handleDoneTrial(userMidi, animationPiano, truth, trialTruth) {
	console.log(...log('_handleDoneTrial(userMidi, animationPiano, trialTruth)'));


	let { on_off_pairs } = await PyFns.merge_on_off_txt_files(trialTruth);
	await userMidi.endOnOffTxtStreamsAndWriteMidi(on_off_pairs, trialTruth);
	// "played_enough_notes" can be false only if didn't pass, otherwise it's true
	// "played_too_many_notes" can be false even if user passed
	// let { passed, mistakes, is_tempo_correct, played_enough_notes, played_too_many_notes } = await PyFns.check_done_trial(truth, trialTruth);
	let doneTrialResult = await PyFns.check_done_trial(truth, trialTruth);

	const levels = EStore.getLevels();

	if (doneTrialResult.passed)
		await Gui.showPassedTrialFeedback(animationPiano, levels, doneTrialResult, truth);
	else  // did not pass
		await Gui.showFailedTrialFeedback(animationPiano, levels, doneTrialResult, truth);

	if (doneTrialResult.advance_trial == false) {
		// don't increase if got wrong accuracy when checking rhythm
		let failIndex = 0;
		console.log(`Trying to rename ${trialTruth.pathNoExt} with failIndex: ${failIndex}`);
		let newPath = `${trialTruth.pathNoExt}_ACCFAIL_${failIndex}`;
		let newPathExists = await fsx.path_exists(`${newPath}.txt`);
		while (newPathExists) {

			failIndex += 1;
			console.log(`\tFile exists, trying failIndex: ${failIndex}`);
			newPath = `${trialTruth.pathNoExt}_ACCFAIL_${failIndex}`;
			newPathExists = await fsx.path_exists(`${newPath}.txt`);
		}
		console.log(`\trenaming to: ${newPath}`);
		const newTruth = new Truth(newPath);
		await trialTruth.txt.renameByOtherTxt(newTruth.txt);
		await trialTruth.midi.renameByOtherFile(newTruth.midi);
	} else { // it's undefined when subject passed
		EStore.increase("current_test.finished_trials_count");

	}
	return doneTrialResult;


}

async function _maybeCreateOutputDir() {
	console.log(...log('_maybeCreateOutputDir()', { sm: true }));
	const outputDir = EStore.testOutPath();
	let exists = await fsx.path_exists(outputDir);

	if (!exists)
		await fsx.mkdir(outputDir + '/', { recursive: true });

	else
		fs.stat(outputDir, async (err, stats) => {

			let datestr = stats.ctime.human();
			await fs.renameSync(outputDir, `${outputDir}_${datestr}`);
			await fsx.mkdir(outputDir + '/', { recursive: true });


		});


}

/**@param {Midi} userMidi
 @param {Truth} truth*/
async function _maybeWriteMidiFileFromTxt(userMidi, truth) {
	console.log(...log('_maybeWriteMidiFileFromTxt(userMidi, truth)', { sm: true }));
	if (await !truth.txt.allExist())
		return Promise.reject(`_maybeWriteMidiFileFromTxt, not all txt files exist for truth: "${truth.name}"`);


	if (await truth.midi.exists()) // good
		return;


	await Python.runAsync('InsideTest/normalize_txt_file.py', { args: [truth.txt.on.path], mode: "json" });
	let msgs = await Python.runAsync('InsideTest/merge_on_off_txt_files.py', {
		args: [truth.txt.base.path, truth.txt.on.path, truth.txt.off.path],
		mode: "json"
	})[0];
	let { on_off_pairs } = msgs[0];
	await Gilad.toMidiFromMessages(on_off_pairs, truth);
}

async function _maybeAlertBadConfig() {
	console.log(...log('_maybeAlertBadConfig()', { sm: true }));
	const levels = EStore.getLevels();
	if (levels.someHaveZeroes()) {
		await Alert.big.blocking({
			title: `I found at least one level with "zero" notes or trials`,
			html: 'You will be redirected to New Test page',
			showCancelButton: false,
		});
		return Pages().newTestPage.switch(true);
	}
	for (let slicedLevels of levels.slicesByNotes())
		for (let level of slicedLevels)
			if (!level.rhythm && level.index != 0) {
				await Alert.big.blocking({
					title: `One rhythm-less level (index: ${level.index}) is preceded by a rhythm level with the same number of notes`,
					html: 'You will be redirected to New Test page',
					showCancelButton: false,
				});
				return Pages().newTestPage.switch(true);
			}


}

/**@param {Truth} truth*/
async function _maybeAlertNoVideo(truth) {
	console.log(...log('_maybeAlertNoVideo(truth)', { sm: true }));
	if (!EStore.isDemoVideo())
		return;
	if (await truth.mp4.exists())
		return; // good
	let movexists = await truth.mov.exists();
	let html = movexists
	           ? `Looks like a .mov file exists though. Go to File Tools?`
	           : `A .mov file doesn't exist either. Switch to Animation mode?`;
	let { value } = await Alert.big.warning({
		title: `Can't find a video file: ${truth.mp4.name}`,
		html,
		showCancelButton: false
	});

	if (value) {
		if (movexists) {
			return Pages().fileToolsPage.switch(true);
		} else {
			EStore.setDemoType('animation');
			return reloadPage();
		}
	}

}

/**@param {Truth} truth*/
async function _maybeCreateOnsetsJson(truth) {
	console.log(...log('_maybeCreateOnsetsJson(truth)', { sm: true }));
	if (!EStore.isDemoVideo())
		return;

	if (!(await truth.onsets.exists())) {
		await Alert.big.blocking({
			title: `Can't find onsets file: ${truth.onsets.name}`,
			html: 'You will be redirected to File Tools page',
			showCancelButton: false,
		});
		return Pages().fileToolsPage.switch(true);

	} else {
		let data = JSON.parse(await fs.readFileSync(truth.onsets.path));
		if (("onsets" in data) && ("first_onset_index" in data))
			return; // good

		console.log('\tonsets file doesnt have both "onsets" and "first_onset_index" keys');
		await Alert.big.blocking({
			title: `Onsets file seems currupt: ${truth.onsets.name}`,
			html: 'You will be redirected to File Tools page',
			showCancelButton: false
		});
		return Pages().fileToolsPage.switch(true);


	}


}

const insideTestPage = {
	switch: async reload => {
		console.group(`insideTestPage.switch(${reload})`);
		await asx.$fadeOutMany(100, $MainContent, $Sidebar, $Title);

		EStore.set({ last_page: 'inside_test', dev: false, 'current_test.finished_trials_count': 0 });
		if (reload)
			return reloadPage();

		Alert.small._info({
			title: 'Checking for missing files...',
			timer: 1000,
			onAfterClose: () => Alert.small._success({ title: 'All good', timer: 1500 })
		});

		let current_test = EStore.currentTest();
		let { finished_trials_count } = current_test;
		// User plays it, does all the txt/mid writing
		let userMidi = new Gilad.Midi({ name: 'insidetest.userMidi', muteUserPiano: true });
		// Passively plays the midi animation
		/**@type {Piano}*/
		let animationPiano = new Piano(`file:///${EStore.salamanderDirPath()}`, 'insidetest.animationPiano', [21, 108], 5).toMaster();
		animationPiano.load();
		const truth = EStore.truth();
		await asx.concurrent(
			_maybeCreateOutputDir(),
			_maybeWriteMidiFileFromTxt(userMidi, truth),
			_maybeAlertBadConfig(),
			_maybeAlertNoVideo(truth),);

		// Video file exists for sure because of _maybeAlertNoVideo
		await _maybeCreateOnsetsJson(truth);
		$MainContent.empty();
		require("pyano_local_modules/sidebar").to_inside_test();
		safeSwitchCss("templates/css/inside_test.css");
		if (EStore.isDemoVideo())
			await video.init(truth);
		$MainContent.append(
			$pageSubtitle,
			$bigMessage,
			$smallMessage,
			$smallMessageSecondary,
			$bigButton,
			animation.$element,
			video.$element);

		$Title.text(`testing ${current_test.current_subject}`.title());
		const levels = EStore.getLevels();
		Gui.updateLevelTrialSubtitles(levels, truth);
		await asx.$fadeIn($MainContent, 300);
		console.groupEnd();
		if (finished_trials_count == 0)
			await Gui.playWholeTruthDemo(animationPiano, truth, levels.maxNotes());

		let trialTruth = await _runTrial({ userMidi, animationPiano, truth });

		Gui.$bigButton
		   .click(async () => {
			   console.log(...log('$bigButton clicked', true));
			   if ((await trialTruth.txt.on.size()) == 0 || (await trialTruth.txt.off.size()) == 0)
				   return Alert.small.warning('Please play something');

			   let doneTrialResult = await _handleDoneTrial(userMidi, animationPiano, truth, trialTruth);


			   if (!EStore.isWholeTestOver()) {
				   console.log(...log('Test aint over!'));
				   trialTruth = await _runTrial({
					   userMidi,
					   animationPiano,
					   truth,
					   playPreTrialDemo: doneTrialResult.advance_trial
				   });
				   // No more logic - user should click $bigButton

			   } else {
				   animationPiano.dispose();
				   await Gui.showTestCompleteMessages();
			   }
		   });


	}
};
module.exports = insideTestPage;

const { EStore } = require("pyano_local_modules/ext_libs");
const Gui = require("./Gui");
const LevelsPart = () => require("./Parts/parts").LevelsPart;

const { remote } = require("electron");
const fs = require("fs");
const Path = require('path');
const PyFns = () => require("./PyFns");
const configsPath = () => require('path').join(EStore.root_abs_path, 'experiments', 'configs');

function saveExperiment() {
	console.log(...small(`NewTest.StoreFns.saveExperiment()`));
	const levels = LevelsPart().getLevelsArr().toTLevels();
	const config = EStore.config();
	config.levels = levels;
	return Alert.small.success(`Saved ${levels.length} levels to config file.`);


}

function saveExperimentAs() {
	console.log(...small(`NewTest.StoreFns.saveExperimentAs()`));
	const dialogOptions = {
		defaultPath: configsPath(),
		filters: [{ name: "JSON", extensions: ['json'] }],
		title: "Save current experiment to file..."
	};
	remote.dialog.showSaveDialog(getCurrentWindow(), dialogOptions, (filename, bookmark) => {
		console.log('saveExperimentAs()', { filename, bookmark });
		if (filename === undefined)
			return Alert.small.warning("Aborting", "No config file saved.");

		try {
			const examData = EStore.config('exam').toObj();
			const testData = EStore.config('test').toObj();
			let data = {
				current_test: testData,
				current_exam: examData,
				experiment_type: EStore.experiment_type
			};
			data = JSON.stringify(data, null, 4);
			fs.writeFileSync(filename, data);

			EStore.save_path = Path.relative(EStore.root_abs_path, filename);
			Alert.small.success("Saved file successfully", filename);
		} catch (e) {
			Alert.small.error(`Failed to save "${fsx.basename(filename)}"!`, e.message);
		}

	});
}

/**@param {string} filename*/
async function _loadExperimentFromFile(filename) {
	await PyFns().validate_fix_saved_config_file(filename);
	EStore.save_path = Path.relative(EStore.root_abs_path, filename);
	/**@type {TSavedConfig}*/
	const data = JSON.parse(await fs.readFileSync(filename));
	EStore.fromObj(data);
	/*EStore.experiment_type = data.experiment_type;
	const exam = EStore.config('exam');
	const test = EStore.config('test');
	for (let [examkey, examvalue] of data.current_exam.items()) {
		try {
			exam[examkey] = examvalue;
		} catch (e) {
			console.warn(`tried setting exam[${examkey}] = ${examvalue}, failed. ignoring. error message:\n${e.message}`);
		}
	}
	for (let [testkey, testvalue] of data.current_test.items()) {
		try {
			test[testkey] = testvalue;
		} catch (e) {
			console.warn(`tried setting test[${testkey}] = ${testvalue}, failed. ignoring. error message:\n${e.message}`);
		}
	}
	*/


	const config = EStore.config();
	Gui.setCurrentSubjectSubtitle(config.current_subject);
	// TODO: setTruthFileSubtitle(EStore.truth())

	Gui.setTruthFileSubtitle(config.truth());

	return reloadPage();
}

function loadExperiment() {
	console.log(...small(`NewTest.StoreFns.loadExperiment()`));

	const dialogOptions = {
		properties: ['openFile'],
		defaultPath: configsPath(),
		filters: [{ name: 'JSON', extensions: ['json'] }],
		title: "Load test config file..."
	};
	remote.dialog.showOpenDialog(getCurrentWindow(), dialogOptions, async files => {
		console.log({ files });
		if (!bool(files))
			return Alert.small.warning("No files chosen", "Nothing changed.");

		const filename = files[0];
		try {
			await _loadExperimentFromFile(filename);
		} catch (e) {
			console.error(e);
			Alert.small.error('Failed to load config', filename);
		}


	});

}

/**@param {string} file*/
function setNewTruth(file) {
	console.log(...small(`NewTest.StoreFns.setNewTruth(${file})`));
	const truthsDirPath = EStore.truthsDirPath();
	if (fsx.dirname(file).lower() != truthsDirPath.lower())
		return Alert.small.warning(`File "${fsx.basename(file)}" isn't in truths dir`, `Place it here: ${truthsDirPath}`);
	let truth;
	try {
		truth = new Truth(fsx.remove_ext(file));
	} catch (err) {
		console.warn(err);
		return Alert.small.error('Failed setting truth file', err.message);
	}
	try {

		const config = EStore.config();
		const truthname = truth.name.lower();
		console.log('config.type', config.type);


		const _configsPath = configsPath();
		// Map of {absolute path:undefined}s of config files
		let configs = new Map(fs.readdirSync(_configsPath)
		                        .filter(cfg => Path.extname(cfg) == '.json')
		                        .map(cfg => [cfg]));

		console.log('configs', configs);

		for (let cfg of configs.keys()) {
			const fullpath = Path.join(_configsPath, cfg);
			const cfgstat = fs.lstatSync(fullpath);
			const data = JSON.parse(fs.readFileSync(fullpath, { encoding: "utf8" }));
			try {
				const _basename = Path.basename(data[`current_${config.type}`].truth_file_path, '.txt').lower();

				if (_basename == truthname) {
					configs[cfg] = cfgstat.mtimeMs;
				} else {
					configs.delete(cfg);
				}
			} catch (e) {
				configs.delete(cfg);
			}


		}
		// get single latest config
		let latestCfg = undefined;
		for (let [cfg, mtime] of configs.items()) {
			if (latestCfg == undefined || latestCfg.mtime < mtime) {
				latestCfg = { cfg, mtime };
			}

		}
		debugger;
		// TODO: this still doesn't work because truth_file_path is set before config lookup starts
		if (latestCfg)
			return _loadExperimentFromFile(Path.join(_configsPath, latestCfg.cfg));
		else
			config.truth_file_path = truth;
		console.log(`\tSet new truth file path: ${truth.name}`);
		Alert.small.success("Set new truth file", truth.name);
		Gui.setTruthFileSubtitle(truth);
	} catch (err) {
		console.warn(err);
		return Alert.small.error('Failed setting truth file', err.message);
	}


}

function browseAndSetNewTruth() {


	const currentWindow = remote.getCurrentWindow();

	const dialogOptions = {
		properties: ['openFile'],
		defaultPath: EStore.truthsDirPath(),
		filters: [{ name: 'Text', extensions: ['txt'] }],
		title: "Load truth file..."
	};
	remote.dialog.showOpenDialog(currentWindow, dialogOptions, files => {
		console.log({ files });
		if (!bool(files))
			return Alert.small.warning("No files chosen", "Nothing changed.");

		setNewTruth(files[0]);
	});
}

module.exports = {
	saveExperiment,
	saveExperimentAs,
	loadExperiment,
	browseAndSetNewTruth,
	setNewTruth
};

const { EStore } = require("pyano_local_modules/ext_libs");
const Gui = require("./Gui");
const LevelsPart = () => require("./Parts/parts").LevelsPart;

const { remote } = require("electron");
const fs = require("fs");
const Path = require('path');
const PyFns = () => require("./PyFns");

function saveExperiment() {
	console.log(...small(`NewTest.StoreFns.saveExperiment()`));
	const levels = LevelsPart().getLevelsArr().toTLevels();
	EStore.config().levels = levels;
	return Alert.small.success(`Saved ${levels.length} levels to ${EStore.save_path}.`);


}

function saveExperimentAs() {
	console.log(...small(`NewTest.StoreFns.saveExperimentAs()`));
	const dialogOptions = {
		defaultPath: EStore.configsPath(),
		filters: [{ name: "JSON", extensions: ['json'] }],
		title: "Save current experiment to file..."
	};
	remote.dialog.showSaveDialog(getCurrentWindow(), dialogOptions, (configfilepath, bookmark) => {
		console.log('saveExperimentAs()', { configfilepath, bookmark });
		if (configfilepath === undefined)
			return Alert.small.info("Aborting", "No config file saved.");

		try {
			const examData = EStore.config('exam').toObj();
			const testData = EStore.config('test').toObj();
			let data = {
				current_test: testData,
				current_exam: examData,
				experiment_type: EStore.experiment_type
			};
			data = JSON.stringify(data, null, 4);
			fs.writeFileSync(configfilepath, data);

			const savePath = Path.relative(EStore.root_abs_path, configfilepath);
			EStore.save_path = savePath;
			Gui.setSavePathSubtitle(savePath);
			Alert.small.success(`Saved experiment to ${savePath}`);
		} catch (e) {
			Alert.small.error(`Failed to save "${fsx.basename(configfilepath)}"`, e.message);
		}

	});
}

/**@param {string} configfilepath - abs path to json*/
async function loadExperimentFromFile(configfilepath) {
	await PyFns().validate_fix_saved_config_file(configfilepath);
	const savePath = Path.relative(EStore.root_abs_path, configfilepath);
	EStore.save_path = savePath;
	/**@type {TSavedConfig}*/
	const data = JSON.parse(await fs.readFileSync(configfilepath));
	EStore.fromSavedConfig(data);


	const config = EStore.config();
	Gui.setSubjectSubtitle(config.current_subject);
	Gui.setTruthSubtitle(config.truth());
	Gui.setSavePathSubtitle(savePath);
	return reloadPage();
}

function loadExperiment() {
	console.log(...small(`NewTest.StoreFns.loadExperiment()`));

	const dialogOptions = {
		properties: ['openFile'],
		defaultPath: EStore.configsPath(),
		filters: [{ name: 'JSON', extensions: ['json'] }],
		title: "Load test config file..."
	};
	remote.dialog.showOpenDialog(getCurrentWindow(), dialogOptions, async files => {
		console.log('loadExperiment()', { files });
		if (!bool(files))
			return Alert.small.info("No files chosen", "Nothing changed.");

		const configfilepath = files[0];
		try {
			await loadExperimentFromFile(configfilepath);
		} catch (e) {
			console.error(e);
			Alert.small.error('Failed to load config', e.message);
		}


	});

}


/**@param {string} file - abs path to txt*/
async function setNewTruth(file) {
	console.log(...small(`NewTest.StoreFns.setNewTruth(${file})`));
	const truthsDirPath = EStore.truthsDirPath();
	if (fsx.dirname(file).lower() != truthsDirPath.lower())
		return Alert.small.warning(`File "${fsx.basename(file)}" isn't in truths dir`, `Place it here: ${truthsDirPath}`);

	try {
		const truth = new Truth(fsx.remove_ext(file));
		const config = EStore.config();
		const newConfig = await Alert.big.blocking({
			title: `Initialize a new config file with ${truth.name}?`,
			text: `Otherwise, current config will be updated`,
			confirmButtonText: `New...`,
			cancelButtonText: `Update current`
		});
		if (newConfig.value) {
			saveExperimentAs();
		} else {
			Alert.small.info(`Config file stayed as before: ${EStore.save_path}`);
		}

		config.truth_file_path = truth;
		Gui.setTruthSubtitle(truth);


		/*const truthname = truth.name.lower();
		let configpaths = _getConfigPathsOfTruth(truthname, config.type);
		Alert.small._info({
			title: `5 recent configs with ${truthname} as their ${config.type} truth:`,
			html: configpaths.slice(5).join(', ')
		});
		*/
	} catch (err) {
		console.warn(err);
		return Alert.small.error('Failed setting truth file', err.message);
	}


}

function browseAndSetNewTruth() {


	const currentWindow = remote.getCurrentWindow();

	const dialogOptions = {
		properties: ['openFile'],
		defaultPath: EStore.truthsDirPath(),
		filters: [{ name: 'Text', extensions: ['txt'] }],
		title: "Load truth file..."
	};
	remote.dialog.showOpenDialog(currentWindow, dialogOptions, files => {
		console.log({ files });
		if (!bool(files))
			return Alert.small.info("No files chosen", "Nothing changed.");

		setNewTruth(files[0]);
	});
}

/**@param {string} truthname
 * @param {TExperimentType} configType*/
function _getConfigPathsOfTruth(truthname, configType) {
	const _configsPath = EStore.configsPath();
	// Map of {file name no ext:undefined}s of config files
	let configsmap = new Map(fs.readdirSync(_configsPath)
	                           .filter(cfg => Path.extname(cfg) == '.json')
	                           .map(cfg => [cfg]));


	for (let cfg of configsmap.keys()) {
		const fullpath = Path.join(_configsPath, cfg);
		const data = JSON.parse(fs.readFileSync(fullpath, { encoding: "utf8" }));
		try {
			const _basename = Path.basename(data[`current_${configType}`].truth_file_path, '.txt').lower();

			if (_basename == truthname)
				configsmap.set(cfg, fs.lstatSync(fullpath).mtimeMs);
			else
				configsmap.delete(cfg);

		} catch (e) { // no "truth_file_path" key.
			configsmap.delete(cfg);
		}
	}
	//	 reaching here: configsmap has a few (or none) cfg:mtime items
	//	 where its current_${configType} matches truthname

	let configpaths = [...configsmap.keys()];
	configpaths.sort((a, b) => configsmap[a] - configsmap[b]);
	console.log('_getConfigPathsOfTruth()', configpaths.slice(5).join(', '));
	return configpaths;

}

module.exports = {
	browseAndSetNewTruth,
	loadExperiment,
	loadExperimentFromFile,
	saveExperiment,
	saveExperimentAs,
	setNewTruth,
};

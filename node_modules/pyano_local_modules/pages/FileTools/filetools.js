const log = s => [`%c${s}`, 'color: #245ed1'];
let { EStore, Python } = require("pyano_local_modules/ext_libs");
let { sum, replace_to_ext, zip, round, path_exists, remove_ext, $fadeOut, $fadeInMany, $fadeOutMany, $fadeIn } = require("pyano_local_modules/util");
let { safeSwitchCss, $MainContent, $Sidebar, $Title } = require("pyano_local_modules/document");
let { Alert } = require("pyano_local_modules/util/Alert");
let Path = require("path");
const $ = require('jquery');
const fs = require("fs");


/**@param {String} filePath
 @param {Number} firstOnset
 @param {Number} silenceLen
 @param {Number?} toSecs
 @param {Number?} notesNum*/
async function trimAndForceSilence(filePath, firstOnset, silenceLen, toSecs, notesNum) {
	console.log(...log(`trimAndForceSilence(filePath, ${firstOnset}, ${silenceLen}, ${toSecs}, ${notesNum})`));
	let options = { args: [filePath, firstOnset, silenceLen] };
	if (toSecs && notesNum)
		options.args.push(toSecs, notesNum);
	const trimmedFilePath = await Python.runAsync("Record/trim_and_force_silence.py", options);
	console.log(...log('\ttrimmedFilePath'), trimmedFilePath);
	return trimmedFilePath[0];


}

async function handleTxt(name, path) {
	let shouldConvert = await Alert.big.blocking({
		title: `Convert ${name} to midi?`
	});
	if (!shouldConvert.value) {
		Alert.small.info('Not converting');
		return;
	}
	let mid = replace_to_ext(path, 'mid');
	if (await path_exists(mid)) {
		Alert.small.warning('Midi file already exists. Aborting.');
		return;
	}
	let { toMidiFromMessages } = require("pyano_local_modules/gilad");

	let messages = await Python.runAsync('InsideTest/normalize_txt_file.py', {
		args: [path],
		mode: "json"
	});
	console.log({ messages });

	try {
		await toMidiFromMessages(messages, mid);
		Alert.small.success(`Created ${replace_to_ext(name, 'mid')}.`);
	} catch (e) {
		Alert.small.error('Converting from txt to midi failed', e);
	}


}

async function handleMid(name, path) {
	let shouldConvert = await Alert.big.blocking({
		title: `Convert ${name} to txt?`
	});
	if (!shouldConvert.value) {
		Alert.small.info('Not converting');
		return;
	}
	if (await path_exists(replace_to_ext(path, 'txt'))) {
		Alert.small.warning('Txt file already exists. Aborting.');
		return;
	}
	let { toTxtFromMidi } = require("pyano_local_modules/gilad");
	try {
		await toTxtFromMidi(path);
		Alert.small.success(`Created ${replace_to_ext(name, 'txt')}.`);
	} catch (e) {
		Alert.small.error('Converting from midi to txt failed', e);
	}

}


async function handleMov(name, path) {
	let mp4path = replace_to_ext(path, 'mp4');
	let mp4name = Path.basename(mp4path);

	// **Confirm
	let { value: shouldConvert } = await Alert.big.blocking({
		title: 'Convert to mp4?',
		html: `${name} => ${mp4name}`,
		showConfirmButton: true,
		showCancelButton: true,
	});
	if (!shouldConvert) {
		Alert.small.info('Not converting.');
		return;
	}
	// **Maybe Delete existing
	if (await path_exists(mp4path)) {
		let { value: doAnyway } = await Alert.big.blocking({
			title: "A converted mp4 version of this file already exists. Continue anyway?",
			html: `Here: ${mp4path}`
		});
		if (doAnyway) {
			await fs.unlinkSync(mp4path);
		} else {
			Alert.small.info('Not converting.');
			return;
		}
	}
	let { execSync } = require('child_process');

	// **Convert
	try {
		execSync(`ffmpeg -i "${path}" -vcodec copy "${mp4path}"`, { encoding: 'utf8', stdio: 'inherit' });
		await MP4.cleanSilence(mp4name, mp4path);
		Alert.small.success('Converted successfully', `New file created: ${mp4path}`);
	} catch (e) {
		console.error(e);
		Alert.small.error('Convert failed', 'Maybe the converted file exists already?');
	}


}

const MP4 = (() => {
	async function createSubVersions(trimmedmp4name, trimmedmp4path) {
		console.log(...log(`createSubVersions(trimmedmp4name, trimmedmp4path)`), { trimmedmp4name, trimmedmp4path });
		let matchingtxttruth = EStore.truthFilesList('txt')
		                             .find(f => remove_ext(f) == trimmedmp4name.upTo('_trimmed'));
		if (!matchingtxttruth)
			return Alert.small.error(`Didn't find a matching truth file`, `Tried to match: ${trimmedmp4name.upTo('_trimmed')}`);

		console.log('\t', { matchingtxttruth });
		let shouldContinue = await Alert.big.blocking({
			title: `Found a matching truth file`,
			html: `Video will be cut based on <b>${matchingtxttruth}</b>`,
		});
		if (!shouldContinue.value)
			return Alert.small.info('Aborting.');


		let levels = EStore.currentTest().levels;
		let notes = levels.map(level => level.notes).rsort();
		shouldContinue = await Alert.big.blocking({
			title: `${notes.length} videos will be created`,
			html: `consisting of these notes, respectively: ${notes}`,
		});
		if (!shouldContinue.value)
			return Alert.small.info('Aborting.');

		let messages = await Python.runAsync('InsideTest/normalize_txt_file.py', {
			args: [Path.join(EStore.truthsDirPath(), matchingtxttruth)],
			mode: "json"
		});
		console.log(...log(`\tafter normalize_txt_file.py`), { messages });
		let tdeltas = messages.slice(0, notes[0]).map(msg => msg.time_delta - 0.01);
		if (notes[0] >= messages.length) {
			// if user specified as much notes as in txt file, add a fake "last note" lasting 1 second
			// this is to prevent cropping of last note
			tdeltas.push(1);
		}
		let vidsDurations = notes.map(notesCount => sum(tdeltas.slice(0, notesCount + 1)));
		console.log('\t', { tdeltas, vidsDurations });
		const silenceLen = EStore.vidSilenceLen();
		let existed = 0;
		for (let [noteCount, vidDur] of zip(notes, vidsDurations)) {
			try {
				trimmedmp4path = await trimAndForceSilence(trimmedmp4path, 0, silenceLen, vidDur, noteCount);
				console.log({ trimmedmp4path });
			} catch (e) {
				if (RegExp("^FileExistsError:.*.mp4$").test(e.message)) {
					existed += 1;
				} else if (RegExp("^FileNotFoundError:.*.json$").test(e.message)) {
					Alert.small.error(`Couldn't find onsets file in truths dir`, `${trimmedmp4name.upTo('_trimmed')}_onsets.json`);
					throw e;
				} else {
					Alert.small.error(`General error`, `Talk to Gilad`);
					throw e;
				}
			}
		}
		let title = `Created ${notes.length - existed} videos`;
		if (existed != 0)
			title += ` (${existed} already existed)`;
		Alert.small.success(title, `of file: ${trimmedmp4name}`);
	}

	async function cleanSilence(mp4name, mp4path) {
		console.log(...log(`cleanSilence(mp4name = ${mp4name}, mp4path)`));
		let trimmedmp4path = `${remove_ext(mp4path)}_trimmed.mp4`;
		// **Confirm
		let { value: shouldClean } = await Alert.big.blocking({
			title: 'Clean silence from start?',
			html: `${mp4name} => ${Path.basename(trimmedmp4path)}`,
		});
		if (!shouldClean) {
			Alert.small.info('Not cleaning.');
			return;
		}
		// **Maybe Delete
		if (await path_exists(trimmedmp4path)) {
			let { value: doAnyway } = await Alert.big.blocking({
				title: "A trimmed version of this file already exists. Continue anyway?",
				html: `Here: ${trimmedmp4path}`
			});
			console.log({ doAnyway });
			if (doAnyway) {
				await fs.unlinkSync(trimmedmp4path);
			} else {
				Alert.small.info('Not trimming.');
				return;
			}
		}
		// **Record/get_and_write_onsets.py
		let onsets = await Python.runAsync("Record/get_and_write_onsets.py", { args: [mp4path] });
		Alert.big.blocking({ title: 'How long was it until you played the first note?' },
			{
				strings: onsets.map(o => round(o, 1)),
				clickFn: async $s => {
					let secs = $s.text();
					Alert.small.info(`Trimming ${secs}s of silence...`);
					try {
						await trimAndForceSilence(mp4path, secs, EStore.vidSilenceLen());
						Alert.small.success(`Trimmed ${secs}s successfully.`);
					} catch (e) {
						Alert.small.error(`Failed trimming ${mp4name}`, e);
					}
				}
			});


	}

	return { cleanSilence, createSubVersions };
})();

async function handleMp4(name, path) {
	if ('trimmed'.in(name)) {
		await MP4.createSubVersions(name, path);
	} else {
		await MP4.cleanSilence(name, path);
	}

}


async function onDrop(e) {
	let { name, path, size, type } = e.originalEvent.dataTransfer.files[0];
	console.log({ name, path, size, type });
	if (type == "audio/mid")
		return await handleMid(name, path);

	if ("text".in(type))
		return await handleTxt(name, path);

	if ("video".in(type)) {
		let ext = Path.extname(name).lower();
		if (ext.endsWith('mov'))
			return await handleMov(name, path);
		if (ext.endsWith('mp4'))
			return await handleMp4(name, path);
		Alert.small.warning(`Can't handle this video format`, `Only 'mov' or 'mp4'`);
		return;
	}
	Alert.small.warning('Can only hanle mp4 / mov / txt / mid');
}

const fileToolsPage = {
	switch: async (reload) => {
		console.log(...log(`fileToolsPage.switch(${reload})`));
		EStore.setLastPage('file_tools');
		if (reload) {
			let { remote } = require("electron");
			const currentWindow = remote.getCurrentWindow();
			currentWindow.reload();
		}
		await $fadeOut($MainContent, 100);
		$MainContent.empty();
		require("pyano_local_modules/sidebar").to_file_tools();
		safeSwitchCss("templates/css/file_tools.css");
		let $bigMessage = $('<div id="big_message">')
			.text('Drop a file');
		let $dropArea = $('<div id="drop_area">')
			.on({
				'dragover dragenter': e => {
					e.preventDefault();
					e.stopPropagation();
				}, 'drop': async e => await onDrop(e)
			});

		$MainContent.append($bigMessage, $dropArea);
		await $fadeIn($MainContent, 300);
	}
};

module.exports = fileToolsPage;

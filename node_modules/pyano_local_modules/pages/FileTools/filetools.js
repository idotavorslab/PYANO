const log = s => [`%c${s}`, 'color: #245ed1'];
let { EStore, Python } = require("pyano_local_modules/ext_libs");
let { date2datetime, int, reloadPage, round, $fadeOut, $fadeIn } = require("pyano_local_modules/util");
let { safeSwitchCss, $MainContent } = require("pyano_local_modules/document");
let { Alert } = require("pyano_local_modules/util/Alert");
let Path = require("path");
const $ = require('jquery');
const fs = require("fs");
let { execSync } = require('child_process');

/**@param {String} filePath
 @param {Number} firstOnset
 @param {Number} silenceLen
 @param {Number?} toSecs
 @param {Number?} notesNum*/

/*async function trimAndForceSilence(filePath, firstOnset, silenceLen, toSecs, notesNum) {
	console.log(...log(`trimAndForceSilence(filePath, ${firstOnset}, ${silenceLen}, ${toSecs}, ${notesNum})`));
	let options = { args: [filePath, firstOnset, silenceLen] };
	if (toSecs && notesNum)
		options.args.push(toSecs, notesNum);
	const trimmedFilePath = await Python.runAsync("Record/trim_and_force_silence.py", options);
	console.log(...log('\ttrimmedFilePath'), trimmedFilePath);
	return trimmedFilePath[0];


}
*/

async function writeFullOnsetsJson(mp4name, mp4path, confirm = true) {
	console.log(...log(`writeFullOnsetsJson(mp4name, mp4path = ${mp4path})`));
	if (confirm) {
		let { value: shouldClean } = await Alert.big.blocking({
			title: 'Get onsets and write data to file?',
			html: `Data will be written to: ${mp4name.upTo('.mp4')}_onsets.json`
		});
		if (!shouldClean) {
			Alert.small.info('Not cleaning.');
			return;
		}
	}
	/*// **Maybe Delete
	if (await path_exists(trimmedmp4path)) {
		let { value: doAnyway } = await Alert.big.blocking({
			title: "A trimmed version of this file already exists. Continue anyway?",
			html: `Here: ${trimmedmp4path}`
		});
		console.log({ doAnyway });
		if (doAnyway) {
			await fs.unlinkSync(trimmedmp4path);
		} else {
			Alert.small.info('Not trimming.');
			return;
		}
	}
	*/

	// **Record/get_and_write_onsets.py
	Alert.small.info('Calculating onsets...');
	let onsets = await Python.runAsync("Record/get_and_write_onsets.py", { args: [mp4path] });
	return await Alert.big.blocking({ title: 'How long was it until you played the first note?' },
		{
			strings: onsets.map(o => round(o, 1)),
			clickFn: async $s => {
				let secs = $s.text();
				Alert.small.info(`Working...`);
				try {
					let options = { args: [mp4path, secs] };
					await Python.runAsync("Record/update_onsets_json.py", options);
					Alert.small.success(`Done.`);
					return true;
				} catch (e) {
					await Alert.small.error(`Failed cleaning ${mp4name}`, e);
					return false;
				}
			}
		});


}

async function handleJson(jsonName, jsonPath) {
	if (!jsonName.endsWith('_onsets.json')) {
		Alert.small.error(`Doesn't look like an onsets file`, `A legal format example: "fur_elise_B_onsets.json"`);
	} else {
		let mp4name = `${jsonName.upTo('_onsets')}.mp4`;
		let mp4path = `${jsonPath.upTo('_onsets')}.mp4`;
		await writeFullOnsetsJson(mp4name, mp4path);
	}
}

async function handleTxt(txtname, txtpath) {
	const txtpathNoExt = fsx.remove_ext(txtpath);
	let txtPathBase;
	if (txtpathNoExt.endsWith('_on'))
		txtPathBase = `${txtpathNoExt.upTo('_on')}.txt`;
	else if (txtpathNoExt.endsWith('_off'))
		txtPathBase = `${txtpathNoExt.upTo('_off')}.txt`;
	else
		txtPathBase = `${txtpathNoExt}.txt`;

	const txtNameBase = fsx.basename(txtPathBase);
	const midipath = fsx.replace_ext(txtPathBase, 'mid');
	const midiname = fsx.basename(midipath);
	let shouldConvert = await Alert.big.blocking({
		title: `Convert ${txtNameBase} to ${midiname}?`
	});
	if (!shouldConvert.value)
		return Alert.small.info('Not converting.');


	if (await fsx.path_exists(midipath)) {
		const midstats = await fs.statSync(midipath);
		const datestr = date2datetime(midstats.birthtime);
		const midipathNew = fsx.push_before_ext(midipath, `_${datestr}`);
		let overwrite = await Alert.big.blocking({
			title: `Midi file already exists. Rename old midi file?`,
			html: `${midiname} => ${fsx.basename(midipathNew)}`
		});
		if (!overwrite.value)
			return Alert.small.info('Aborting.');
		else
			await fs.renameSync(midipath, midipathNew);

	}

	let messages = await Python.runAsync('InsideTest/get_messages_from_file.py', {
		args: [txtPathBase],
		mode: "json"
	});

	console.log({ messages });

	let { toMidiFromMessages } = require("pyano_local_modules/gilad");
	try {
		await toMidiFromMessages(messages, midipath);
		Alert.small.success(`Created ${midiname}.`);
	} catch (e) {
		Alert.small.error('Converting from txt to midi failed', e);
	}


}

async function handleMid(midiname, midipath) {
	const txtName = fsx.replace_ext(midiname, 'txt');
	let shouldConvert = await Alert.big.blocking({
		title: `Create 3 txt files from ${midiname}?`
	});
	if (!shouldConvert.value)
		return Alert.small.info('Not converting');

	const pathNoExt = fsx.remove_ext(midipath);
	const txtPathOn = `${pathNoExt}_on.txt`;
	const txtPathOff = `${pathNoExt}_off.txt`;
	const txtPathBase = `${pathNoExt}.txt`;
	let [onExists, offExists, baseExists] = await asx.concurrent(
		fsx.path_exists(txtPathOn),
		fsx.path_exists(txtPathOff),
		fsx.path_exists(txtPathBase));


	if (any(onExists, offExists, baseExists)) {
		let shouldOverwrite = await Alert.big.blocking({
			title: `At least one txt file already exists, overwrite *all*?`
		});
		if (!shouldOverwrite.value)
			return Alert.small.info('Aborting.');

		await asx.concurrent(
			fs.unlinkSync(txtPathBase),
			fs.unlinkSync(txtPathOn),
			fs.unlinkSync(txtPathOff)
		);

	}
	let { toTxtFromMidi } = require("pyano_local_modules/gilad");
	try {
		let [txtPathBase, txtPathOn, txtPathOff] = await toTxtFromMidi(midipath);
		let on_messages = await Python.runAsync('InsideTest/normalize_txt_file.py', {
			args: [txtPathOn],
			mode: "json"
		});
		let all_messages = await Python.runAsync('InsideTest/merge_on_off_txt_files.py', {
			args: [txtPathBase, txtPathOn, txtPathOff],
			mode: "json"
		});
		console.log({ all_messages, on_messages });

		Alert.small.success(`Created ${fsx.basenames(txtPathOn, txtPathOff, txtPathBase)}.`);
	} catch (e) {
		Alert.small.error(`Converting ${midiname} to ${txtName} failed`, e.message);
	}

}


async function handleMov(movname, movpath) {

	console.log(...log(`handleMov(movname, movpath = ${movpath})`));
	let mp4path = fsx.replace_ext(movpath, 'mp4');
	let mp4name = Path.basename(mp4path);


	// **Confirm
	let { value: shouldConvert } = await Alert.big.blocking({
		title: 'Crop and create an mp4? (may take a while)',
		html: `${movname} => ${mp4name}`,
		showConfirmButton: true,
		showCancelButton: true,
	});
	if (!shouldConvert) {
		Alert.small.info('Aborting');
		return;
	}
	// **Maybe Delete existing
	let overwrite = false;
	if (await fsx.path_exists(mp4path)) {
		let { value: doAnyway } = await Alert.big.blocking({
			title: "An mp4 at destination already exists. Overwrite?",
			html: `Here: ${mp4path}`
		});
		if (doAnyway)
			overwrite = true;
		else
			return Alert.small.info('Aborting');

	}

	// **Convert
	try {

		await Alert.big.blocking({
			title: "Working...", html: "Here's a hamster: ðŸ¹", showConfirmButton: false,
			showCancelButton: false,

		});
		let yesflag = overwrite ? "-y" : "";
		let cmd = `ffmpeg ${yesflag} -i "${movpath}" -filter:v "crop=1900:400:10:360" -qp 18 -preset ultrafast -tune zerolatency -profile:v baseline -level 3.0 -movflags +faststart "${mp4path}"`;
		await execSync(cmd, { encoding: 'utf8', stdio: 'inherit' });
		await writeFullOnsetsJson(mp4name, mp4path);
		Alert.small.success('Success', `New file created: ${mp4path}`);
	} catch (e) {
		console.error(e);
		Alert.small.error('Error', e);
	}


}


async function handleMp4(mp4name, mp4path) {
	const ffprobeCmd = `ffprobe -v quiet -print_format json -show_streams -show_format`;
	const mp4probe = JSON.parse(await execSync(`${ffprobeCmd} "${mp4path}"`, { encoding: 'utf8' }));
	let { bit_rate: mp4bitrate, height: mp4height } = mp4probe.streams.find(s => s["codec_type"] == "video");
	let compressed = int(mp4bitrate) / 1000000 < 20;
	let cropped = int(mp4height) < 600;
	if (!compressed || !cropped) {
		const movpath = fsx.replace_ext(mp4path, 'mov');
		if (await fsx.path_exists(movpath)) {
			const movprobe = JSON.parse(await execSync(`${ffprobeCmd} "${movpath}"`, { encoding: 'utf8' }));
			let { bit_rate: movbitrate, height: movheight } = movprobe.streams.find(s => s["codec_type"] == "video");
			compressed |= int(movbitrate) / int(mp4bitrate) > 2;
			cropped |= int(movheight) / int(mp4height) > 1.2;

		}
	}
	if (compressed || cropped) {
		let { value: createOnsets } = await Alert.big.blocking({
			title: "This mp4 looks already compressed or cropped.",
			html: `Only the onsets file will be created. Continue?`
		});
		if (!createOnsets)
			return await Alert.small.info("Aborting");
		return await writeFullOnsetsJson(mp4name, mp4path);
	}
	return await handleMov(mp4name, mp4path);


}


async function onDrop(e) {
	// let {remote} = require('electron');
	require('electron').remote.getCurrentWindow().focus();
	let { name, path, size, type } = e.originalEvent.dataTransfer.files[0];
	console.log({ name, path, size, type });
	if (type == "audio/mid")
		return await handleMid(name, path);
	if (type == "application/json")
		return await handleJson(name, path);

	if ("text".in(type))
		return await handleTxt(name, path);

	if ("video".in(type)) {
		let ext = Path.extname(name).lower();
		if (ext.endsWith('mov'))
			return await handleMov(name, path);
		if (ext.endsWith('mp4'))
			return await handleMp4(name, path);
		Alert.small.warning(`Can't handle this video format`, `Only 'mov' or 'mp4'`);
		return;
	}

	Alert.small.warning('Can only hanle mp4 / mov / txt / json / mid');
}

const fileToolsPage = {
	switch: async reload => {
		console.log(...log(`fileToolsPage.switch(${reload})`));
		EStore.setLastPage('file_tools');
		if (reload) {
			return reloadPage();
		}
		await $fadeOut($MainContent, 100);
		$MainContent.empty();
		require("pyano_local_modules/sidebar").to_file_tools();
		safeSwitchCss("templates/css/file_tools.css");
		let $bigMessage = $('<div id="big_message">')
			.text('Drop a file');
		let $dropArea = $('<div id="drop_area">')
			.on({
				'dragover dragenter': e => {
					e.preventDefault();
					e.stopPropagation();
				}, 'drop': async e => await onDrop(e)
			});

		$MainContent.append($bigMessage, $dropArea);
		await $fadeIn($MainContent, 300);
	}
};

module.exports = fileToolsPage;

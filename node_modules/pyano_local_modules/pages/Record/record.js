// **pages/Record/record.js
// const sidebar = require("pyano_local_modules/sidebar/index.js");
let { safeSwitchCss, $MainContent } = require("pyano_local_modules/document");
let Gui = require("./Gui");
let { bool, path_exists, remove_ext, zip, $fadeInMany, $fadeOutMany, $fadeOut, $fadeIn, underscore2space, round } = require('pyano_local_modules/util');
let { EStore, Python } = require("pyano_local_modules/ext_libs");

let { Midi } = require("pyano_local_modules/gilad");
let { Alert, blockingSwalMixin } = require("pyano_local_modules/util/Alert");
const $ = require("jquery");
let Piano = require("pyano_local_modules/gilad/Piano");
let { remote } = require("electron");
let Vid = require("./video");
const path = require('path');
const fs = require("fs");
const truthsDirPath = EStore.truthsDirPath();
const recC = 'color:#a70334';

/**@param {Midi} recordMidi*/
async function _startRecord(recordMidi) {
	console.log('%c_startRecord(recordMidi)', recC);
	$fadeOut(Gui.$editableSpan, 300);
	await recordMidi.newTxtStreamAndMaybeLoadUserPiano(_getRecordPath('txt'));
	Gui.animateRecordBtn({ on: true });
}

/**@param {Midi} recordMidi
 @param {Piano|Tone.AudioNode} playbackPiano*/
async function _stopRecord(recordMidi, playbackPiano) {
	console.log('%c_stopRecord(recordMidi, playbackPiano)', recC);
	let messages = await Python.runAsync('InsideTest/normalize_txt_file.py', { args: [_getRecordPath('txt')], mode: "json" });
	// let messages = await PyFns.normalizeTxtFile(_getRecordPath('txt'));
	await recordMidi.endTxtAndWriteMidi(messages, _getRecordPath('mid'));
	Gui.animateRecordBtn({ on: false });
	const recordName = Gui.setEditableSpanText(null);
	$fadeIn(Gui.$editableSpan, 0);
	Gui.repopulateTruthFiles()
	   .map(async $f => $f.click(async e => await _playTruthFile(e, recordMidi, playbackPiano)));
	EStore.setTruthFilePath(recordName);
	// playbackPiano.dispose();
	Alert.small.success('Saved files', `${recordName}.txt, ${recordName}.mid`);
}

/**@param {String} ext*/
function _getRecordPath(ext) {
	console.log(`%c__getRecordPath(ext = ${ext})`, recC);
	const recordNameNoExt = Gui.getEditableSpanText();
	const recordPathNoExt = path.join(truthsDirPath, recordNameNoExt);
	return `${recordPathNoExt}.${ext}`;
}

/**@param e
 @param {Midi} recordMidi
 @param {Piano|Tone.AudioNode} playbackPiano*/
async function _playTruthFile(e, recordMidi, playbackPiano) {
	console.log('%c_playTruthFile(...)', recC);
	const id = e.currentTarget.id;
	const $currentTarget = $(e.currentTarget);
	$currentTarget
		.css('color', 'white')
		.text(underscore2space(id) + ' ðŸ”Š');

	const midiFilePath = path.join(truthsDirPath, `${id}.mid`);
	await recordMidi.playMidiFile({ midiFilePath, playbackPiano });
	$currentTarget
		.css('color', 'rgba(255,255,255,0.65)')
		.text(underscore2space(id) + ' ðŸ”ˆ');
}

async function createVidSubVersions() {
	console.log('%c_createVidSubVersions()', recC);
	let truthFilePathNoExt = EStore.truthFilePath();
	let trimmedFilePath = `${remove_ext(truthFilePathNoExt)}_trimmed.mp4`;
	// let trimmedExists = await path_exists(trimmedFilePath);
	if (!(await path_exists(trimmedFilePath))) {
		let { value: shouldTrim } = await Alert.small.warning("A trimmed version of this file does NOT exist. Create one?", `Destination: ${trimmedFilePath}`, true);
		console.log('\t', { shouldTrim });
		if (!shouldTrim) {
			Alert.small.info('Not trimming; aborting operation.');
			return;
		} else {
			await trimRawVidFile(`${truthFilePathNoExt}.mp4`);
		}
	}
	const silenceLen = EStore.vidSilenceLen();
	let levels = EStore.currentTest().levels;
	let notes = levels.map(level => level.notes).rsort();
	console.log('\t', { notes, trimmedFilePath, truthFilePathNoExt });
	let messages = await Python.runAsync('InsideTest/normalize_txt_file.py', { args: [`${truthFilePathNoExt}.txt`], mode: "json" });
	console.log('\t', { messages });
	let tdeltas = messages.slice(0, notes[0]).map(msg => msg.time_delta - 0.01);
	if (notes[0] >= messages.length) {
		// if user specified as much notes as in txt file, add a fake "last note" lasting 1 second
		// this is to prevent cropping of last note
		tdeltas.push(1);
	}
	console.log('\t', { tdeltas });
	let vidsDurations = notes.map(notesCount => tdeltas.slice(0, notesCount + 1).reduce((n, m) => n + m));
	console.log('\t', { vidsDurations });
	let existed = 0;
	for (let [noteCount, vidDur] of zip(notes, vidsDurations)) {
		try {
			let trimmedPath = await Vid.trimAndForceSilence(trimmedFilePath, 0, silenceLen, vidDur, noteCount);
			console.log('\t', { trimmedPath });
		} catch (e) {
			if (RegExp("^FileExistsError:.*.mp4$").test(e.message))
				existed += 1;
		}
	}
	let title = `Created ${notes.length - existed} videos`;
	if (existed != 0)
		title += ` (${existed} already existed)`;
	Alert.small.success(title, `of file: ${truthFilePathNoExt}`);
}

async function trimRawVidFile(vidFilePath = null) {
	console.log('%c_trimRawVidFile()', recC);
	if (vidFilePath == null)
		vidFilePath = await Vid.browseForVideoFile();
	if (vidFilePath == null)
		return; // user cancelled selection
	let vidFileName = path.basename(vidFilePath);
	if (vidFileName.endsWith('_trimmed.mp4')) {
		let { value: shouldTrim } = await Alert.small.warning("Are you sure?", `Looks like this file is already trimmed: ${vidFileName}`, true);
		console.log({ shouldTrim });
		if (!bool(shouldTrim)) {
			Alert.small.info('Not trimming.');
			return;
		}
	} // file doesn't end with "_trimmed.mp4"
	vidFilePath = await Vid.maybeMoveVideoFile(vidFilePath);
	let trimmedFilePath = `${remove_ext(vidFilePath)}_trimmed.mp4`;
	let trimmedExists = await path_exists(trimmedFilePath);
	console.log({ trimmedFilePath, trimmedExists });
	if (trimmedExists) {
		let { value: doAnyway } = await Alert.small.warning("A trimmed version of this file already exists. Continue anyway?", `Here: ${trimmedFilePath}`, true);
		console.log({ doAnyway });
		if (doAnyway) {
			await fs.unlinkSync(trimmedFilePath);
		} else {
			Alert.small.info('Not trimming.');
			return;
		}
	}
	const onsets = await Vid.getOnsetTimes(vidFilePath);
	Alert.big.blocking({ title: 'How long was it until you played the first note?' },
		{
			strings: onsets.map(o => round(o, 1)),
			clickFn: async $s => {
				console.log(`user chose ${$s.text()}`);
				await Vid.trimAndForceSilence(vidFilePath, $s.text(), EStore.vidSilenceLen());
				await blockingSwalMixin.close();
				let { value: setAsTruth } = await Alert.small.info('Trimmed successfully. Set as current truth file?', null, true);
				if (setAsTruth) {
					let truthFileNameNoExt = path.basename(vidFilePath, '.mp4');
					EStore.setTruthFilePath(truthFileNameNoExt);
					Alert.small.success(`Set as truth file`, truthFileNameNoExt);
				}
			}
		});


}

const recordPage = {
	/**@param {Boolean} reload*/
	switch: async (reload) => {
		EStore.set('last_page', 'record');
		if (reload) {
			const currentWindow = remote.getCurrentWindow();
			currentWindow.reload();
		}
		await $fadeOutMany(100, $MainContent);
		require("pyano_local_modules/sidebar/index.js").to_record();
		$MainContent.empty();
		safeSwitchCss("templates/css/record.css");

		$MainContent.append(
			Gui.$recordBtn,
			Gui.$inputDiv,
			Gui.$recordPath,
			Gui.truthFilesDiv,
			Gui.videoProcessDiv
		);
		$('#video_file_browse_btn')
			.click(async () => await trimRawVidFile());

		$('#video_file_subvideos_btn')
			.click(async () => await createVidSubVersions());
		let recordMidi = new Midi({ muteUserPiano: true });

		let playbackPiano = new Piano(`file:///${EStore.salamanderDirPath()}`, [21, 108], 5).toMaster();

		await $fadeInMany(300, $MainContent);
		let alreadyRecording = false;
		Gui.$getTruthFiles()
		   .map(async $f => $f.click(async e => await _playTruthFile(e, recordMidi, playbackPiano)));
		Gui.$recordBtn.click(async () => {
			if (!alreadyRecording) {

				await _startRecord(recordMidi);

			} else {
				await _stopRecord(recordMidi, playbackPiano);
			}
			alreadyRecording = !alreadyRecording;
		});
	}
};
module.exports = recordPage;

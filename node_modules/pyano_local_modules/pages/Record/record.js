let { safeSwitchCss, $MainContent } = require("pyano_local_modules/document");
let Gui = require("./Gui");
let { reloadPage, $fadeInMany, $fadeOut, $fadeIn, underscore2space } = require('pyano_local_modules/util');
let { EStore, Python } = require("pyano_local_modules/ext_libs");

let { Midi } = require("pyano_local_modules/gilad");
const $ = require("jquery");
let Piano = require("pyano_local_modules/gilad/Piano");
const truthsDirPath = EStore.truthsDirPath();
const log = s => [`%c${s}`, 'color: #a70334'];

/**@param {Midi} recordMidi*/
async function _startRecord(recordMidi) {
	console.log(...log('_startRecord(recordMidi)'));
	$fadeOut(Gui.$editableSpan, 300);
	try {
		await recordMidi.newOnOffTxtWriteStreams(_getRecordTruth());
		Gui.animateRecordBtn({ on: true });
		Alert.small.info('Record started');
	} catch (e) {
		console.err(e);
		Alert.small.error("Can't record", e);
	}
}

/**@param {Midi} recordMidi
 @param {Piano} playbackPiano*/
async function _stopRecord(recordMidi, playbackPiano) {
	console.log(...log('_stopRecord(recordMidi, playbackPiano)'));
	const truth = _getRecordTruth();
	const fs = require("fs");

	let { size: onSize } = await fs.lstatSync(truth.txt.on.path);
	let { size: offSize } = await fs.lstatSync(truth.txt.off.path);
	if (onSize == 0 || offSize == 0) {
		await Alert.small._warning({ title: 'Nothing was recorded', html: 'Page will reload in 2 seconds', timer: 2000 });
		await asx.concurrent(
			fs.unlinkSync(truth.txt.on.path),
			fs.unlinkSync(truth.txt.off.path),
		);
		return reloadPage();
	}

	let on_messages = await Python.runAsync('InsideTest/normalize_txt_file.py', { args: [truth.txt.on.path], mode: "json" });
	let msgs = await Python.runAsync('InsideTest/merge_on_off_txt_files.py', {
		args: [truth.txt.base, truth.txt.on, truth.txt.off],
		mode: "json"
	});
	let { on_off_pairs } = msgs[0];

	await recordMidi.endOnOffTxtStreamsAndWriteMidi(on_off_pairs, truth);
	Gui.animateRecordBtn({ on: false });
	const recordName = Gui.setEditableSpanText(null);
	$fadeIn(Gui.$editableSpan, 0);

	Gui.repopulateTruthFiles()
	   .map(async $f =>
		   $f.click(async e =>
			   await _playTruthFile(e, recordMidi, playbackPiano)));
	try {
		await EStore.setTruthFilePath(recordName);
		Alert.small.success('Saved files', `${recordName}.txt, ${recordName}.mid`);
	} catch (e) {
		console.warn(e);
		Alert.small.error('Error setting new truth file', e.message);
	}
	playbackPiano.dispose();
}

/**@return {Truth}*/
function _getRecordTruth() {
	console.log(...log(`_getRecordTruth()`));
	const recordNameNoExt = Gui.getEditableSpanText();
	const recordPathNoExt = require('path').join(truthsDirPath, recordNameNoExt);
	return new Truth(recordPathNoExt);

}

/**@param e
 @param {Midi} recordMidi
 @param {Piano} playbackPiano*/
async function _playTruthFile(e, recordMidi, playbackPiano) {
	console.log(...log(`_playTruthFile(...)`));
	const id = e.currentTarget.id;
	const $currentTarget = $(e.currentTarget);
	$currentTarget
		.css('color', 'white')
		.text(underscore2space(id) + ' ðŸ”Š');

	const truth = new Truth(require('path').join(truthsDirPath, id));
	const { playMidiFile } = require("pyano_local_modules/gilad");
	try {
		await playMidiFile({ truth, playbackPiano });
		$currentTarget
			.css('color', 'rgba(255,255,255,0.65)')
			.text(underscore2space(id) + ' ðŸ”ˆ');
	} catch (e) {
		console.error(e);
		Alert.small.error("Can't play", e);
	}
}


const recordPage = {
	/**@param {boolean} reload*/
	switch: async reload => {
		EStore.set('last_page', 'record');
		if (reload)
			return reloadPage();

		await $fadeOut($MainContent, 100);
		require("pyano_local_modules/sidebar/index.js").to_record();
		$MainContent.empty();
		safeSwitchCss("templates/css/record.css");

		$MainContent.append(
			Gui.$recordBtn,
			Gui.$inputDiv,
			Gui.$recordPath,
			Gui.truthFilesDiv
		);

		let recordMidi = new Midi({ name: 'record.recordMidi', muteUserPiano: true });

		let playbackPiano = new Piano(`file:///${EStore.salamanderDirPath()}`, 'record.playbackPiano', [21, 108], 5).toMaster();
		playbackPiano.load();
		await $fadeInMany(300, $MainContent);
		let alreadyRecording = false;
		Gui.$getTruthFiles()
		   .map(async $f =>
			   $f.click(async e =>
				   await _playTruthFile(e, recordMidi, playbackPiano)
			   )
		   );
		Gui.$recordBtn.click(async () => {
			if (!alreadyRecording) {

				await _startRecord(recordMidi);

			} else {
				try {
					await _stopRecord(recordMidi, playbackPiano);
				} catch (e) {
					console.warn(e);
					await Alert.big.warning({
						title: 'Stopping record failed',
						html: e,
						confirmButtonText: 'Reload (recommended)',
					});
					const truth = _getRecordTruth();
					await truth.txt.removeAll();
					return reloadPage();

				}
			}
			alreadyRecording = !alreadyRecording;
		});
	}
};
module.exports = recordPage;

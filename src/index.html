<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Pyano</title>

    <script id="globals" type="text/javascript" defer>
		 console.log('index.html globals');
		 // *** Prototypes
		 // ** Object
		 Object.defineProperty(Object.prototype, "isEmpty", {
			 enumerable: false,
			 value() {
				 return Object.keys(this).length == 0;
			 }
		 },);
		 Object.defineProperty(Object.prototype, "items", {
			 enumerable: false,
			 value() {
				 return enumerate(this);
			 }
		 });
		 Object.defineProperty(Object.prototype, "keys", {
			 enumerable: false,
			 value() {
				 return Object.keys(this).map(key => key.isdigit()
				                                     ? int(key) : key);
			 }
		 });
		 // ** Array
		 Object.defineProperty(Array.prototype, "last", {
			 enumerable: false,
			 value() {
				 return this[this.length - 1];
			 }
		 },);
		 Object.defineProperty(Array.prototype, "lowerAll", {
			 enumerable: false,
			 value() {
				 return this.map(s => s.lower());
			 }
		 },);
		 Object.defineProperty(Array.prototype, "rsort", {
			 enumerable: false,
			 value() {
				 return this.sort((n, m) => n < m);
			 }
		 },);
		 Object.defineProperty(Array.prototype, "count", {
			 enumerable: false,
			 value(item, strict = false) {
				 let _count = 0;
				 for (let x of this) {
					 if (strict) {
						 if (x === item)
							 _count++;

					 } else if (x == item) {
						 _count++;
					 }
				 }
				 return _count;

			 }

		 },);
		 // ** String
		 Object.defineProperty(String.prototype, "upTo", {
			 enumerable: false,
			 value(searchString, fromEnd = false) {
				 let end = fromEnd
				           ? this.lastIndexOf(searchString)
				           : this.indexOf(searchString);
				 return this.slice(0, end);
			 }
		 },);
		 Object.defineProperty(String.prototype, "in", {
			 enumerable: false,
			 value(arr) {
				 return arr.includes(this.valueOf());
			 }
		 },);
		 Object.defineProperty(String.prototype, "lower", {
			 enumerable: false,
			 value() {
				 return this.toLowerCase();
			 }
		 },);
		 Object.defineProperty(String.prototype, "upper", {
			 enumerable: false,
			 value() {
				 return this.toUpperCase();
			 }
		 },);
		 Object.defineProperty(String.prototype, "title", {
			 enumerable: false,
			 value() {

				 if (this.includes(' '))
					 return this.split(' ').map(str => str.title()).join(' ');
				 else
					 return this[0].upper() + this.slice(1, this.length).lower();

			 }
		 },);
		 Object.defineProperty(String.prototype, "isdigit", {
			 enumerable: false,
			 value() {
				 return !isNaN(Math.floor(this));
			 }
		 },);
		 Object.defineProperty(String.prototype, "replaceAll", {
			 enumerable: false,
			 value(searchValue, replaceValue) {
				 const type = typeof searchValue;
				 if (type == 'string' || type == 'number') {
					 return this
						 .split(searchValue)
						 .join(replaceValue);
				 } else if (type == 'object') {
					 let temp = this;
					 for (let [sv, rv] of searchValue.items())
						 temp = temp.replaceAll(sv, rv);

					 return temp;
				 } else {
					 console.error(`replaceAll got a bad type, searchValue: ${searchValue}, type: ${type}`);
				 }
			 }
		 });
		 // ** Number
		 Object.defineProperty(Number.prototype, "human", {
			 enumerable: false,
			 value(letters = false) {
				 switch (Math.floor(this) + 1) {
					 case 0:
						 return letters
						        ? "zeroth"
						        : "0th";
					 case 1:
						 return letters
						        ? "first"
						        : "1st";
					 case 2:
						 return letters
						        ? "second"
						        : "2nd";
					 case 3:
						 return letters
						        ? "third"
						        : "3rd";
					 case 4:
						 return letters
						        ? "fourth"
						        : "4th";
					 case 5:
						 return letters
						        ? "fifth"
						        : "5th";
					 case 6:
						 return letters
						        ? "sixth"
						        : "6th";
					 case 7:
						 return letters
						        ? "seventh"
						        : "7th";
					 case 8:
						 return letters
						        ? "eighth"
						        : "8th";
					 case 9:
						 return letters
						        ? "ninth"
						        : "9th";

					 default:
						 return `${this}th`;
				 }

			 }
		 });
		 // ** Date
		 Object.defineProperty(Date.prototype, "human", {
			 enumerable: false, value() {
				 let d = this.getUTCDate();
				 d = d < 10
				     ? `0${d}`
				     : d;
				 let m = this.getMonth() + 1;
				 m = m < 10
				     ? `0${m}`
				     : m;
				 const y = this.getFullYear();
				 const t = this.toTimeString().slice(0, 8).replaceAll(':', '-');
				 return `${d}_${m}_${y}_${t}`;
			 }
		 });

		 // *** functions
		 const { Alert } = require('pyano_local_modules/util/Alert');
		 const Path = require("path");


		 const any = (...items) => items.some(item => bool(item));
		 const all = (...items) => items.every(item => bool(item));

		 /**@param val
		  * @return {boolean}*/
		 function bool(val) {
			 /*
			 |               | o instanceof Object   | typeof o == 'object'  |  !!o  |
			 |  -----------  |  ------------------   |  -------------------  | ----- |
			 |  {}           |         true          |         true          | true  |
			 |  []           |         true          |         true          | true  |
			 |  ()=>{}       |         true          |         false         | true  |
			 |  new class{}  |         true          |         true          | true  |
			 |  (()=>{})()   |         false         |         false         | false |
			 |  0            |         false         |         false         | false |
			 |  ""           |         false         |         false         | false |
			 |  null         |         false         |         true          | false |
			 |  undefined    |         false         |         false         | false |
			 |  "0"          |         false         |         false         | true  |
			 |  "foo"        |         false         |         false         | true  |
			 */

			 if (val == null)
				 return false;
			 const valType = typeof val;
			 if (valType != 'object') {
				 if (valType == 'function')
					 return true;
				 else
					 return !!val;
			 }
			 return !val.isEmpty();
			 /*if (val instanceof Object) {
				 if (val.isEmpty())
					 return typeof val == 'function';
				 else
					 return true;

			 } else {
				 return !!val;
			 }
			 */
		 }

		 /**@template T
		  * @param {T[]|T} collection
		  * @return {[string|number|T]}*/
		 function enumerate(collection) {
			 let entries = Object.entries(collection);
			 entries.map(entry => entry[0] = entry[0].isdigit()
			                                 ? int(entry[0])
			                                 : entry[0]);
			 return entries;
		 }

		 const float = (str) => parseFloat(str);
		 /**
		  @param {string|number} num
		  @return {number}
		  */
		 const int = (num) => Math.floor(num);
		 /**@param {...number} values*/
		 const max = (...values) => Math.max(...values);
		 const min = (...values) => Math.min(...values);

		 function* range(start, stop) {
			 for (let i = start; i <= stop; i++)
				 yield i;

		 }

		 /**@param {number} n
		  * @param {number} d
		  * @return {number}*/
		 function round(n, d = 0) {
			 let fr = 10 ** d;
			 return int(n * fr) / fr;
		 }

		 const small = (...args) => [`%c${args.join(' ')}`, `font-size:10px`];
		 const str = (val) => val ? val.toString() : "";

		 /**@param {*[]} arr*/
		 function sum(arr) {
			 let sum = 0;
			 let dirty = false;
			 for (let v of arr) {
				 let number = float(v);
				 if (!isNaN(number)) {
					 dirty = true;
					 sum += number;
				 }

			 }
			 return !dirty ? null : sum;
		 }


		 function* zip(arr1, arr2) {
			 for (let key in arr1)
				 yield [arr1[key], arr2[key]];
		 }

		 function reloadPage() {
			 let { remote } = require("electron");
			 const currentWindow = remote.getCurrentWindow();
			 currentWindow.reload();
		 }

		 function isEqual(obja, objb) {
			 if (any(Array.isArray(obja), Array.isArray(objb)))
				 throw new Error("At least one object is an Array. Pass dict-like objects only");
			 const typeA = typeof obja;
			 const typeB = typeof objb;
			 if (typeA != 'object' || typeB != 'object')
				 throw new Error("At least one object is not `typeof ... == 'object'`. Pass dict-like objects only");

			 if (Object.keys(obja).length != Object.keys(objb).length)
				 return false;
			 for (let [objaK, objaV] of enumerate(obja))
				 if (!(objaK in objb) || objaV != objb[objaK])
					 return false;

			 return true;

		 }

		 // *** fsx
		 const fsx = (() => {
			 const fs = require("fs");
			 /**@param {PathLike|string} pathLike
			  * @param {{mode?:number, recursive?:boolean}} options
			  * @return {Promise<boolean>}*/
			 const mkdir = (pathLike, options) => new Promise(resolve =>
				 fs.mkdir(pathLike, options, err => resolve(!bool(err))));

			 /**@param {PathLike|string} pathLike
			  * @return {Promise<boolean>}*/
			 const path_exists = pathLike => new Promise(resolve =>
				 fs.access(pathLike, fs.constants.F_OK, err => resolve(!bool(err))));

			 /**
			  {@link remove_ext Uses remove_ext}
			  @param {PathLike|string} pathLike
			  @param {string} ext - Target extension without dot
			  @return {string}*/
			 const replace_ext = (pathLike, ext) => {
				 if (ext.includes('.'))
					 throw new Error(`ext included dot ".", ext: ${ext}`);
				 return `${remove_ext(pathLike)}.${ext}`;
			 };

			 /**
			  * @param {PathLike|string} pathLike
			  * @return {string}
			  * @example
			  * remove_ext("experiments/truths/fur_elise_B.txt")
			  * >>> experiments/truths/fur_elise_B
			  * remove_ext("fur_elise_B.txt")
			  * >>> fur_elise_B */
			 const remove_ext = pathLike => Path.join(Path.dirname(pathLike), Path.basename(pathLike, Path.extname(pathLike)));

			 /**
			  * {@link remove_ext Uses remove_ext}
			  * @param {PathLike|string} pathLike
			  * @param {string|number} push
			  * @return {string}
			  * */
			 const push_before_ext = (pathLike, push) => {
				 let ext = Path.extname(pathLike);
				 return `${remove_ext(pathLike)}${push}${ext}`;
			 };

			 /**@param {string|PathLike} pathLike
			  * @param {?string} ext*/
			 function basename(pathLike, ext = null) {
				 if (!ext)
					 return Path.basename(pathLike);
				 return Path.basename(pathLike, ext);
			 }

			 /**@param {...string} paths
			  * @return {string[]}
			  * */
			 function basenames(...paths) {
				 return [...paths.map(p => Path.basename(p))];
			 }

			 /**@param {string} pathLike
			  * @return {string}*/
			 function dirname(pathLike) {
				 return Path.dirname(pathLike);
			 }

			 /**@param {string} pathLike
			  * @return {string}*/
			 function extname(pathLike) {
				 return Path.extname(pathLike);
			 }

			 /** @type {{
			  * basename:(function(string|PathLike,?string):string),
			  * basenames:(function(...string|PathLike):string[]),
			  * dirname:(function(...string|PathLike):string),
			  * extname:(function(...string|PathLike):string),
			  * mkdir: (function((PathLike|string), (number|string|MakeDirectoryOptions|undefined|null)): Promise<boolean>),
			  * path_exists: (function((PathLike|string)): Promise<boolean>),
			  * push_before_ext: (function((PathLike|string), (string|number)): string),
			  * remove_ext: (function((PathLike|string)): string),
			  * replace_ext: (function((PathLike|string), string): string)}}
			  * */
			 return { basenames, basename, dirname, extname, mkdir, path_exists, replace_ext, remove_ext, push_before_ext };
		 })();

		 // *** asx
		 const asx = (() => {
			 /**@param {number} ms
			  * @return {Promise}*/
			 async function wait(ms) {
				 return new Promise(resolve => setTimeout(resolve, ms));
			 }

			 /**@param {jQuery} jQuery
			  @param {number} ms
			  @return {Promise<jQuery>}*/
			 const $fadeOut = (jQuery, ms) => new Promise(resolve => jQuery.fadeTo(ms, 0, resolve));

			 /**@param {jQuery} jQuery
			  @param {number} ms
			  @reutrn {Promise<jQuery>}*/
			 const $fadeIn = (jQuery, ms) => new Promise(resolve => jQuery.fadeTo(ms, 1, resolve));

			 /**@param {number} ms
			  @param {...jQuery} jQueries
			  @return {Promise<jQuery[]>}*/
			 async function $fadeInMany(ms, ...jQueries) {
				 let promises = [];
				 for (let jQ of jQueries)
					 promises.push($fadeIn(jQ, ms));

				 return await Promise.all(promises);
			 }

			 /**@param {number} ms
			  @param {...jQuery} jQueries
			  @return {Promise<jQuery[]>}*/
			 async function $fadeOutMany(ms, ...jQueries) {
				 let promises = [];
				 for (let jQ of jQueries)
					 promises.push($fadeOut(jQ, ms));

				 return await Promise.all(promises);
			 }

			 /**@template T
			  * @param {...Promise<T>|Promise<void>|T|void} promises
			  * @return {Promise<T[]>}*/
			 async function concurrent(...promises) {
				 return await Promise.all(promises);
			 }

			 /**@template T
			  * @param {...function():Promise<T>|T|void} fns
			  * @return {Promise<T[]>}*/
			 async function waterfall(...fns) {
				 for (let fn of fns)
					 await fn();
			 }

			 /**@type {
			  *     {
			  *         $fadeIn: (function(jQuery, number): Promise<jQuery>),
			  *         $fadeInMany: (function(number, ...jQuery): jQuery[]),
			  *         $fadeOut: (function(jQuery, number): Promise<jQuery>),
			  *         $fadeOutMany: (function(number, ...jQuery): jQuery[]),
			  *         concurrent: (function(...function(): T): T[])
			  *         wait: (function(number): Promise<*>),
			  *     }
			  * }
			  * @template T*/
			 const newVar = {
				 $fadeIn,
				 $fadeOut,
				 $fadeOutMany,
				 $fadeInMany,
				 concurrent,
				 wait,
				 waterfall,
			 };
			 return newVar;
		 })();

		 /**An object wrapping a path with extension. Can be absolute or base.
		  * ``toString()`` returns ``this.path``.
		  * ``name`` property exists only if wrapping an absolute path.*/
		 class _File {
			 constructor(pathWithExt) {
				 if (!bool(Path.extname(pathWithExt)))
					 throw new Error(`File constructor: passed 'pathWithExt' is extensionless: ${pathWithExt}`);
				 /**The path including extension. Can be either absolute or a file name.
				  * @type {string} path*/
				 this.path = pathWithExt;
				 /**The path without extension. Can be either absolute or a file name.
				  * @type {string} pathNoExt*/
				 this.pathNoExt = fsx.remove_ext(this.path);
				 if (Path.isAbsolute(this.path))
					 /**If exists, a File object of the basename.
					  * @type {_File} name*/
					 this.name = new _File(fsx.basename(this.path));

			 }

			 toString() {
				 return this.path;
			 }

			 /**@param {_File} other*/
			 async renameByOtherFile(other) {
				 const fs = require("fs");
				 await fs.renameSync(this.path, other.path);
			 }

			 async renameByCTime() {
				 const fs = require("fs");

				 const stats = await fs.lstatSync(this.path);
				 const datestr = stats.ctime.human();
				 const newPath = fsx.push_before_ext(this.path, `__CREATED_${datestr}`);
				 console.log('renameByCTime() to: ', newPath);
				 await fs.renameSync(this.path, newPath);
			 }

			 /**@throws {Error} error if file isn't "mp4" or "mov"
			  * @return {Promise<[string,string]>}
			  * */
			 async getBitrateAndHeight() {
				 if (!this.path.endsWith('mp4') && !this.path.endsWith('mov'))
					 throw new Error(`_File: "${this.path}" isn't "mp4" or "mov"`);
				 const { execSync } = require('child_process');
				 const ffprobeCmd = `ffprobe -v quiet -print_format json -show_streams -show_format`;
				 const probe = JSON.parse(await execSync(`${ffprobeCmd} "${this.path}"`, { encoding: 'utf8' }));
				 const { bit_rate, height } = probe.streams.find(s => s["codec_type"] == "video");
				 return [bit_rate, height];
			 }


			 /**@return {Promise<boolean>}*/
			 async exists() {
				 return await fsx.path_exists(this.path);
			 }

			 /**@return {Promise<void>}*/
			 async remove() {
				 return await require('fs').unlinkSync(this.path);
			 }

			 /**@return {number}*/
			 async size() {
				 let { size } = await require("fs").lstatSync(this.path);
				 return size;
			 }
		 }

		 class Truth {
			 /**An object wrapping an absolute path without extension.
			  * @param {string} pathNoExt*/
			 constructor(pathNoExt) {
				 if (!Path.isAbsolute(pathNoExt))
					 throw new Error(`Passed path is not absolute: ${pathNoExt}`);
				 if (bool(fsx.extname(pathNoExt)))
					 throw new Error(`Passed path is not extensionless: ${pathNoExt}`);
				 if (pathNoExt.endsWith('off') || pathNoExt.endsWith('on'))
					 throw new Error(`Passed path of "_on" or "_off" file and not base: ${pathNoExt}`);
				 /**The absolute path without extension.
				  * @type {string} pathNoExt*/
				 this.pathNoExt = pathNoExt;
				 /**The basename without extension.
				  * @type {string} name*/
				 this.name = fsx.basename(this.pathNoExt);
				 /**
				  * @prop {_File} base - A _File object representing the absolute ``*.txt`` path.
				  * @prop {_File} on - A _File object representing the absolute ``*_on.txt``  path.
				  * @prop {_File} off - A _File object representing the absolute ``*_off.txt`` path.
				  * */
				 this.txt = new class {
					 /**@param {string} pathNoExt*/
					 constructor(pathNoExt) {
						 this.base = new _File(`${pathNoExt}.txt`);
						 this.on = new _File(`${pathNoExt}_on.txt`);
						 this.off = new _File(`${pathNoExt}_off.txt`);
					 }

					 /**@return {[_File,_File,_File]}*/
					 getAll() {
						 return [this.base, this.on, this.off];
					 }

					 /**@return {_File[]}*/
					 async getMissing() {
						 let missing = [];
						 if (!(await this.base.exists()))
							 missing.push(this.base);
						 if (!(await this.on.exists()))
							 missing.push(this.on);
						 if (!(await this.off.exists()))
							 missing.push(this.off);

						 return missing;
					 }

					 /**@return {Promise<boolean>}*/
					 async allExist() {
						 return all(...await asx.concurrent(
							 this.base.exists(),
							 this.on.exists(),
							 this.off.exists()));
					 }

					 /**@return {Promise<boolean>}*/
					 async anyExist() {
						 return any(...await asx.concurrent(
							 this.base.exists(),
							 this.on.exists(),
							 this.off.exists()));
					 }

					 /**@return {Promise<void>}*/
					 async removeAll() {
						 if (await this.base.exists())
							 await this.base.remove();
						 if (await this.on.exists())
							 await this.on.remove();
						 if (await this.off.exists())
							 await this.off.remove();

					 }

					 async renameByOtherTxt(other) {
						 const fs = require("fs");
						 return await asx.concurrent(
							 fs.renameSync(this.base.path, other.base.path),
							 fs.renameSync(this.on.path, other.on.path),
							 fs.renameSync(this.off.path, other.off.path),
						 );
					 }


				 }(this.pathNoExt);

				 /**A _File object of the midi file.
				  * @type {_File} midi*/
				 this.midi = new _File(`${this.pathNoExt}.mid`);
				 /**A _File object of the mp4 file.
				  * @type {_File} mp4*/
				 this.mp4 = new _File(`${this.pathNoExt}.mp4`);
				 /**A _File object of the mov file.
				  * @type {_File} mov*/
				 this.mov = new _File(`${this.pathNoExt}.mov`);
				 /**A _File object of the onsets file.
				  * @type {_File} onsets*/
				 this.onsets = new _File(`${this.pathNoExt}_onsets.json`);

			 }

			 /**Counts the number of non-empty lines in the txt on path file.
			  @return {number}*/
			 numOfNotes() {
				 return require("fs")
					 .readFileSync(this.txt.on.path, { encoding: 'utf8' })
					 .split('\n')
					 .filter(line => bool(line)).length;
			 }
		 }

		 /**@class*/
		 class Level {
			 /**@param {TLevel} level
			  @param {number?} index
			  @param {number?} internalTrialIndex*/
			 constructor(level, index, internalTrialIndex) {
				 const { notes, rhythm, tempo, trials } = level;
				 this.notes = notes;
				 this.rhythm = rhythm;
				 this.tempo = tempo;
				 this.trials = trials;
				 this.index = index;
				 this.internalTrialIndex = internalTrialIndex;
			 }

			 isFirstTrial() {
				 if (this.internalTrialIndex == undefined)
					 throw new Error("internalTrialIndex is undefined");
				 return this.internalTrialIndex == 0;
			 }

			 hasZeroes() {
				 return !bool(this.notes) || !bool(this.trials);
			 }
		 }

		 /**@class*/
		 class Levels {
			 /**@param {TLevel[]} levels*/
			 constructor(levels) {
				 this._levels = levels.map((level, index) => new Level(level, index));
			 }

			 /**@return {boolean}*/
			 someHaveZeroes() {
				 return this._levels.some(level => level.hasZeroes());
			 }

			 /**@return {Array<Levels>}*/
			 slicesByNotes() {
				 let byNotes = {};
				 for (let level of this._levels) {
					 if (level.notes in byNotes) {
						 byNotes[level.notes].addLevel(level);
					 } else {
						 byNotes[level.notes] = new Levels([level]);
					 }
				 }
				 return Object.values(byNotes);
			 }

			 /**@param {Level} level*/
			 addLevel(level) {
				 this._levels.push(level);
			 }

			 /**@param {function(value:Level, index:number, obj:Level[]):boolean} predicate*/
			 findIndex(predicate) {
				 return this._levels.findIndex(predicate);
			 }

			 [Symbol.iterator]() { return this._levels.values(); }
		 }
    </script>
    <script src="jquery.js" defer></script>
    <link rel="stylesheet" href="animate.min.css">
    <link rel="stylesheet" href="templates/css/index.css">
    <link id="page_css" rel="stylesheet" href="templates/css/new_test.css">
    <script src="templates/js/types.js" defer></script>
    <script src="templates/js/init.js" defer></script>


</head>
<body>

<div id="title"></div>
<div id="sidebar"></div>
<div id="main_content"></div>
</body>
</html>
